<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enquadramento de Carteira - HIGHPAR</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React and Babel for component-based UI -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- PapaParse for CSV handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/papaparse/5.3.2/papaparse.min.js"></script>

    <!-- SheetJS/XLSX for Excel file handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- Firebase v9 Compatibility Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-storage-compat.js"></script>


    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; /* slate-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; /* slate-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }

        /* Hides the print-only content from the screen */
        .printable-content {
            display: none;
        }

        /* Improved Print Styles */
        @media print {
            body, html {
                background-color: #fff !important;
                color: #000 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                height: auto !important;
                overflow: visible !important;
                font-size: 10px; /* Base font size for print */
                margin: 0;
                padding: 0;
            }
             /* Hide screen-only elements, including the main app root */
            body > #root, .no-print {
                display: none !important;
            }
            /* Show print-only content and ensure it's the only thing visible */
            .printable-content {
                display: block !important;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
            }
            .presentation-slide {
                width: 100% !important;
                height: 100vh !important; /* Force each slide to take a full page height */
                page-break-after: always !important; /* Ensure each slide starts on a new page */
                display: flex !important;
                flex-direction: column !important;
                visibility: visible !important;
                opacity: 1 !important;
                position: relative !important; /* Changed from absolute to relative for page flow */
                transform: none !important;
                border: 1px solid #e2e8f0 !important; /* slate-200 */
                background: #fff !important;
                color: #0f172a !important; /* slate-900 */
                overflow: hidden !important; /* Hide overflow in print */
                padding: 1.5rem !important; /* Reduced padding for print */
                box-sizing: border-box; /* Include padding/border in element's total width/height */
            }
            /* Ensure text colors are dark for print */
            .presentation-slide h1, .presentation-slide h2, .presentation-slide h3, .presentation-slide p,
            .presentation-slide span, .presentation-slide th, .presentation-slide td, .presentation-slide div,
            .presentation-slide svg, .presentation-slide text {
                color: #0f172a !important; /* slate-900 */
                fill: #0f172a !important; /* For SVG text */
            }
             /* Adjust backgrounds to light/white */
            .presentation-slide .bg-slate-800, .presentation-slide .bg-slate-700,
            .presentation-slide .bg-slate-900, .presentation-slide .bg-slate-700\/50,
            .presentation-slide .bg-slate-600\/50 {
                background-color: #f8fafc !important; /* slate-50 */
                border-color: #cbd5e1 !important; /* slate-300 */
            }
            /* Adjust borders */
            .presentation-slide .border-slate-700, .presentation-slide .border-slate-600, .presentation-slide .border-slate-500 {
                border-color: #cbd5e1 !important; /* slate-300 */
            }
            /* Override specific text colors */
            .presentation-slide .text-white, .presentation-slide .text-slate-200,
            .presentation-slide .text-slate-300, .presentation-slide .text-slate-400 {
                color: #1e293b !important; /* slate-800 */
            }
            .presentation-slide .text-sky-400, .presentation-slide .text-sky-500 { color: #0ea5e9 !important; }
            .presentation-slide .text-green-400 { color: #22c55e !important; }
            .presentation-slide .text-red-400 { color: #ef4444 !important; }
            .presentation-slide .text-yellow-400 { color: #f59e0b !important; }
            .presentation-slide .bg-sky-500 { background-color: #0ea5e9 !important; color: #fff !important; }
            .presentation-slide table {
                 page-break-inside: avoid !important; /* Try to keep tables on one page */
            }
            /* Ensure chart segments are visible */
             .presentation-slide circle[stroke] {
                stroke-opacity: 1 !important;
             }
             .presentation-slide div[style*="background-color:"] {
                 background-color: inherit !important; /* Attempt to inherit calculated color */
                 -webkit-print-color-adjust: exact !important;
                 print-color-adjust: exact !important;
             }
             .presentation-slide .h-4.rounded-full[style*="width:"] { /* Target bar chart bars */
                border: 1px solid #ccc !important; /* Add border for visibility if bg color fails */
             }

            .slide-content-print {
                flex-grow: 1;
                display: flex;
                flex-direction: column;
                justify-content: center; /* Center content vertically */
                overflow: hidden; /* Prevent content overflow */
            }
            .slide-header-print {
                display: flex !important;
                justify-content: space-between !important;
                align-items: center !important;
                border-bottom: 1px solid #cbd5e1 !important;
                padding-bottom: 0.75rem !important; /* Reduced padding */
                margin-bottom: 0.75rem !important; /* Reduced margin */
                flex-shrink: 0;
            }
             .slide-header-print h2 { font-size: 1.25rem !important; } /* Adjust header font size */

            .slide-footer-print {
                text-align: center !important;
                border-top: 1px solid #cbd5e1 !important;
                padding-top: 0.5rem !important; /* Reduced padding */
                margin-top: 0.75rem !important; /* Reduced margin */
                font-size: 8px !important; /* Smaller font for footer */
                color: #475569 !important;
                flex-shrink: 0;
            }
            /* Hide slide navigation in print */
            .presentation-slide-nav {
                display: none !important;
            }
             /* Ensure SVG colors print */
            svg path[fill] {
                fill: currentColor !important;
                 -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
             svg circle[stroke] {
                 stroke: currentColor !important; /* Use explicit color if possible */
                 -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
             }
             /* Specific fix for pie chart segment colors */
             .presentation-slide svg circle[stroke^="#"] {
                 stroke: var(--print-color, black) !important; /* Set a fallback or use CSS vars if possible */
             }
        }
    </style>
</head>
<body class="bg-slate-900 text-white">
    <div id="root"></div>

    <script type="text/babel">
        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyDeAjUfGfnj1aLrym1NaJ_wMp1nzhmdgPw",
          authDomain: "enquadramento-de-carteira.firebaseapp.com",
          projectId: "enquadramento-de-carteira",
          storageBucket: "enquadramento-de-carteira.firebasestorage.app",
          messagingSenderId: "547291070273",
          appId: "1:547291070273:web:d800bf84374a5d8aefabc0",
          measurementId: "G-Q5205EXRBD"
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();
        const serverTimestamp = firebase.firestore.FieldValue.serverTimestamp;

        const { useState, useEffect, useMemo, useCallback, Fragment, useRef } = React;

        // --- SVG ICON COMPONENTS ---
        const Icon = ({ path, className = "h-6 w-6" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
                <path d={path} />
            </svg>
        );
        const ICONS = {
            DASHBOARD: "M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z",
            SETTINGS: "M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61-.25-1.17.59-1.69-.98l-2.49-1c-.23-.09-.49 0-.61-.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19-.15-.24-.42-.12-.64l2 3.46c.12.22.39.3.61-.22l2.49-1c.52.4 1.08.73 1.69-.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z",
            LOGOUT: "M17 7l-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z",
            CHEVRON_DOWN: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z",
            CHEVRON_UP: "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z",
            CHEVRON_LEFT: "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z",
            CHEVRON_RIGHT: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z",
            PLUS: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z",
            CLOSE: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z",
            UPLOAD: "M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z",
            DOWNLOAD: "M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z",
            EDIT: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z",
            TRASH: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z",
            CHART: "M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z",
            PDF: "M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm-2.5-2H15V8.5h-2.5v1.5zm-5-1.5H9v1.5h-.5V8.5zM22 12c0 1.1-.9 2-2 2V4c0-1.1-.9-2-2-2H4C2.9 2 2 2.9 2 4v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-8z",
            CLOCK: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z",
        };

        const Loader = ({className}) => <svg className={`animate-spin ${className}`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>;

        // --- UTILITY FUNCTIONS ---
        const formatCurrency = (value) => {
            const num = parseFloat(value);
            if (isNaN(num)) return "R$ 0,00";
            return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(num);
        };
        const formatPercent = (value, decimals = 2) => {
             const num = parseFloat(value);
            if (isNaN(num)) return `0,${'0'.repeat(decimals)}%`;
            return `${(num * 100).toFixed(decimals).replace('.',',')}%`;
        }

        // Improved Date Parsing/Formatting
        const parseDate = (dateValue) => {
            if (!dateValue) return null;
            let date;

            // Firestore Timestamp
            if (dateValue && typeof dateValue.seconds === 'number') {
                date = new Date(dateValue.seconds * 1000);
            }
            // YYYY-MM-DD string
            else if (typeof dateValue === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(dateValue)) {
                const parts = dateValue.split('-');
                date = new Date(Date.UTC(parts[0], parts[1] - 1, parts[2]));
            }
            // Excel Serial Number (handle potential string representation)
            else if (typeof dateValue === 'number' || (typeof dateValue === 'string' && /^\d{5,}$/.test(dateValue))) {
                 try {
                     // Ensure it's a number
                     const excelSerial = Number(dateValue);
                     if (!isNaN(excelSerial) && excelSerial > 0) {
                         // Base date for Excel is 1899-12-30 (not 31 due to Lotus 1-2-3 bug)
                         const baseDate = new Date(Date.UTC(1899, 11, 30));
                         date = new Date(baseDate.getTime() + (excelSerial - 1) * 24 * 60 * 60 * 1000);
                     }
                 } catch (e) { console.warn("Could not parse Excel date:", dateValue, e); }
             }
             // Try standard JS Date parsing as a fallback
            else if (typeof dateValue === 'string') {
                 try { date = new Date(dateValue); } catch (e) { /* ignore */ }
             }

            // Return valid date or null
            return (date && !isNaN(date.getTime())) ? date : null;
        }

        const formatDisplayDate = (dateValue) => {
            const date = parseDate(dateValue);
            if(date) {
                return new Intl.DateTimeFormat('pt-BR', { timeZone: 'UTC' }).format(date);
            }
            // Return original value if parsing failed but it exists
            return dateValue ? dateValue.toString() : 'N/A';
        };

        // Calculate difference in days between two dates
        const dateDiffInDays = (date1, date2) => {
            if (!date1 || !date2) return Infinity; // Treat missing dates as very far in the future
            const utc1 = Date.UTC(date1.getFullYear(), date1.getMonth(), date1.getDate());
            const utc2 = Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate());
            return Math.floor((utc1 - utc2) / (1000 * 60 * 60 * 24));
        };

        // Parse Liquidez field into days (e.g., "D+30", "30", "Imediata") -> number
        const parseLiquidityDays = (liquidityStr) => {
             if (!liquidityStr || typeof liquidityStr !== 'string') return 2; // Default
             const lowerStr = liquidityStr.toLowerCase().trim();
             if (lowerStr === 'imediata' || lowerStr === 'd+0' || lowerStr === '0') return 0;
             const match = lowerStr.match(/^(?:d\+|)(\d+)$/);
             if (match && match[1]) {
                 const days = parseInt(match[1], 10);
                 return isNaN(days) ? 2 : days;
             }
             return 2; // Default if no pattern matches
        };


        const normalizeString = (str) => {
            if (!str) return '';
            return str
                .toString()
                .trim()
                .toLowerCase()
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "");
        };

        const INSTITUICOES = ['XP', 'BTG', 'XP INTERNACIONAL', 'BTG INTERNACIONAL', 'AVENUE', 'BANCO DO BRASIL', 'SICOOB', 'BRADESCO', 'SANTANDER', 'SAFRA', 'NUBANK', 'INTER'];

        // --- MAIN APP COMPONENT ---
        function App() {
            const [user, setUser] = useState(null);
            const [userData, setUserData] = useState(null);
            const [loading, setLoading] = useState(true);
            const [page, setPage] = useState('dashboard');
            const [selectedClientId, setSelectedClientId] = useState(null);

             useEffect(() => {
                 let unsubscribeUserDoc = () => {};
                 const unsubscribeAuth = auth.onAuthStateChanged((currentUser) => {
                     unsubscribeUserDoc(); // Unsubscribe from previous listener if exists

                     if (currentUser) {
                         const userDocRef = db.collection("users").doc(currentUser.uid);
                         unsubscribeUserDoc = userDocRef.onSnapshot(async (doc) => {
                             if (doc.exists) {
                                 setUser(currentUser);
                                 setUserData({ uid: currentUser.uid, ...doc.data() });
                                 setLoading(false);
                             } else {
                                  // Attempt to auto-create user document ONLY if it doesn't exist
                                 try {
                                     const role = currentUser.email.toLowerCase().includes('admin') ? 'admin' : 'consultant';
                                     const name = currentUser.displayName || currentUser.email.split('@')[0];
                                     await userDocRef.set({
                                         name: name,
                                         email: currentUser.email,
                                         role: role,
                                     });
                                     // setUserData will be updated by the onSnapshot listener automatically after creation
                                      console.log("User document auto-created for:", currentUser.email);
                                 } catch (error) {
                                     console.error("Failed to auto-create user document:", error);
                                      // Proceed without full user data if creation fails
                                     setUser(currentUser);
                                     setUserData(null); // Explicitly set to null if data fetch/create failed
                                     setLoading(false);
                                 }
                             }
                         }, (error) => {
                              // Handle errors fetching the user document snapshot
                             console.error("Error fetching user data snapshot:", error);
                             setUser(currentUser); // Keep the authenticated user
                             setUserData(null); // But indicate user data is unavailable
                             setLoading(false);
                         });
                     } else {
                          // No user logged in
                         setUser(null);
                         setUserData(null);
                         setLoading(false);
                     }
                 });

                  // Cleanup function to unsubscribe from listeners when component unmounts
                 return () => {
                     unsubscribeAuth();
                     unsubscribeUserDoc();
                 };
             }, []); // Empty dependency array ensures this effect runs only once on mount


            const handleSignOut = () => {
                auth.signOut();
                setPage('dashboard');
                setSelectedClientId(null);
            };

            if (loading) {
                return <div className="h-screen w-full flex items-center justify-center"><Loader className="h-12 w-12 text-sky-400" /></div>;
            }

            if (!user) {
                return <LoginPage />;
            }

             // Handle case where user is authenticated but user data could not be fetched/created
            if (user && !userData) {
                 return (
                     <div className="h-screen w-full flex flex-col items-center justify-center text-center p-8 bg-slate-900 text-white">
                         <h1 className="text-2xl text-red-400 font-bold mb-4">Erro de Perfil</h1>
                         <p className="text-slate-400 mb-6 max-w-md">Não foi possível carregar ou criar os dados do seu perfil. Verifique as regras de segurança do Firebase ou entre em contato com o suporte.</p>
                         <button
                             onClick={handleSignOut}
                             className="px-6 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition-colors"
                         >
                             Sair
                         </button>
                     </div>
                 );
             }


            return (
                <div className="min-h-screen bg-slate-900 flex">
                    <Sidebar user={userData} setPage={setPage} handleSignOut={handleSignOut} currentPage={page} />
                    <main className="flex-1 p-8 overflow-y-auto">
                        {page === 'dashboard' && <Dashboard user={userData} setPage={setPage} setSelectedClientId={setSelectedClientId} />}
                        {page === 'client' && <ClientDetail clientId={selectedClientId} user={userData} setPage={setPage} />}
                        {page === 'settings' && userData?.role === 'admin' && <SettingsPage />}
                    </main>
                </div>
            );
        }

        // --- COMPONENTS ---
        function Sidebar({ user, setPage, handleSignOut, currentPage }) {
            const NavItem = ({ iconPath, text, pageName }) => (
                <button
                    onClick={() => setPage(pageName)}
                    className={`flex items-center w-full px-4 py-3 text-sm font-medium rounded-lg transition-colors duration-200 group ${
                        currentPage === pageName ? 'bg-sky-500 text-white' : 'text-slate-300 hover:bg-slate-700 hover:text-white'
                    }`}
                >
                    <Icon path={iconPath} className={`h-5 w-5 ${currentPage === pageName ? 'text-white' : 'text-slate-400 group-hover:text-white'}`} />
                    <span className="ml-3">{text}</span>
                </button>
            );

            return (
                <aside className="w-64 bg-slate-800 p-4 flex flex-col justify-between border-r border-slate-700 no-print">
                    <div>
                        <div className="flex items-center mb-8 px-2">
                            <Icon path={ICONS.CHART} className="h-8 w-8 text-sky-400" />
                            <h1 className="ml-2 text-xl font-bold text-white">HIGHPAR</h1>
                        </div>
                        <nav className="space-y-2">
                            <NavItem iconPath={ICONS.DASHBOARD} text="Dashboard" pageName="dashboard" />
                            {user?.role === 'admin' && <NavItem iconPath={ICONS.SETTINGS} text="Configurações" pageName="settings" />}
                        </nav>
                    </div>
                    <div className="border-t border-slate-700 pt-4">
                       <div className="px-4 py-3">
                            <p className="text-sm font-medium text-white truncate">{user?.name}</p>
                            <p className="text-xs text-slate-400 truncate">{user?.email}</p>
                        </div>
                        <button
                            onClick={handleSignOut}
                            className="flex items-center w-full px-4 py-3 text-sm font-medium text-slate-300 hover:bg-slate-700 hover:text-white rounded-lg transition-colors duration-200 group"
                        >
                            <Icon path={ICONS.LOGOUT} className="h-5 w-5 text-slate-400 group-hover:text-white" />
                            <span className="ml-3">Sair</span>
                        </button>
                    </div>
                </aside>
            );
        }

        function LoginPage() {
            const [isLogin, setIsLogin] = useState(true);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [name, setName] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);

            const handleAuth = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);
                try {
                    if (isLogin) {
                        await auth.signInWithEmailAndPassword(email, password);
                    } else {
                        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                        const role = email.toLowerCase().includes('admin') ? 'admin' : 'consultant';
                        await db.collection("users").doc(userCredential.user.uid).set({
                            name: name,
                            email: email,
                            role: role,
                        });
                        // No need to manually update state, onAuthStateChanged will handle it
                    }
                } catch (err) {
                    console.error("Authentication error:", err);
                    // Provide more specific error messages based on err.code if needed
                    if (err.code === 'auth/user-not-found' || err.code === 'auth/wrong-password') {
                       setError("E-mail ou senha inválidos.");
                    } else if (err.code === 'auth/email-already-in-use') {
                        setError("Este e-mail já está em uso.");
                    } else if (err.code === 'auth/weak-password') {
                        setError("A senha deve ter pelo menos 6 caracteres.");
                    } else {
                       setError("Ocorreu um erro. Tente novamente.");
                    }
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="min-h-screen bg-slate-900 flex flex-col items-center justify-center p-4">
                    <div className="w-full max-w-md">
                        <div className="flex justify-center items-center mb-6">
                            <Icon path={ICONS.CHART} className="h-10 w-10 text-sky-400" />
                            <h1 className="ml-3 text-3xl font-bold text-white">HIGHPAR</h1>
                        </div>
                        <div className="bg-slate-800 p-8 rounded-xl shadow-2xl">
                            <h2 className="text-2xl font-semibold text-center text-white mb-2">{isLogin ? 'Bem-vindo de volta!' : 'Crie sua conta'}</h2>
                            <p className="text-sm text-slate-400 text-center mb-6">{isLogin ? 'Faça login para continuar' : 'Preencha para se registrar'}</p>
                            <form onSubmit={handleAuth} className="space-y-4">
                                {!isLogin && (
                                    <input type="text" placeholder="Nome Completo" value={name} onChange={(e) => setName(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-sky-500" required />
                                )}
                                <input type="email" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-sky-500" required />
                                <input type="password" placeholder="Senha" value={password} onChange={(e) => setPassword(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-sky-500" required />

                                {error && <p className="text-red-400 text-xs text-center">{error}</p>}

                                <button type="submit" disabled={loading} className="w-full py-3 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition-colors duration-200 disabled:bg-sky-800 disabled:cursor-not-allowed flex items-center justify-center">
                                    {loading && <Loader className="h-5 w-5 mr-2" />}
                                    {isLogin ? 'Entrar' : 'Registrar'}
                                </button>
                            </form>
                            <p className="text-center text-sm text-slate-400 mt-6">
                                {isLogin ? 'Não tem uma conta?' : 'Já tem uma conta?'}
                                <button onClick={() => { setIsLogin(!isLogin); setError(''); }} className="font-semibold text-sky-400 hover:text-sky-300 ml-1">
                                    {isLogin ? 'Registre-se' : 'Faça login'}
                                </button>
                            </p>
                        </div>
                    </div>
                </div>
            );
        }

        const calculateFrameworkStatus = (portfolio, profile) => {
            if (!portfolio || portfolio.length === 0 || !profile || !profile.allocations) {
                return { status: 'Aguardando Ativos', deviation: 100 };
            }

            const totalValue = portfolio.reduce((sum, asset) => sum + asset.Valor, 0);
            if (totalValue === 0) return { status: 'Aguardando Ativos', deviation: 100 };

            const currentAllocationByClass = portfolio.reduce((acc, asset) => {
                const key = asset.Classe + (asset.Subclasse ? ` - ${asset.Subclasse}` : '');
                if (!acc[key]) acc[key] = 0;
                acc[key] += asset.Valor;
                return acc;
            }, {});

            const recommendedAllocationMap = profile.allocations.reduce((acc, alloc) => {
                if ((alloc.subcategories || []).length > 0) {
                    alloc.subcategories.forEach(sub => {
                        const key = alloc.Classe + (sub.name ? ` - ${sub.name}` : '');
                        acc[normalizeString(key)] = sub.percentage / 100;
                    });
                } else {
                    const key = alloc.Classe;
                    if(key) acc[normalizeString(key)] = alloc.percentage / 100;
                }
                return acc;
            }, {});

            const currentAllocationMap = Object.entries(currentAllocationByClass).reduce((acc, [key, value]) => {
                acc[normalizeString(key)] = value / totalValue;
                return acc;
            }, {});

            const allKeys = [...new Set([...Object.keys(currentAllocationMap), ...Object.keys(recommendedAllocationMap)])];

            let totalDeviation = 0;
            allKeys.forEach(key => {
                const current = currentAllocationMap[key] || 0;
                const recommended = recommendedAllocationMap[key] || 0;
                totalDeviation += Math.abs(current - recommended);
            });

            const deviationPercentage = (totalDeviation / 2) * 100;

            if (deviationPercentage <= 5) return { status: 'Enquadrado', deviation: deviationPercentage };
            if (deviationPercentage <= 20) return { status: 'Atenção', deviation: deviationPercentage };
            return { status: 'Desenquadrado', deviation: deviationPercentage };
        };

        const StatusBadge = ({ status, deviation }) => {
            const styleMap = {
                'Enquadrado': 'bg-green-500/20 text-green-400',
                'Atenção': 'bg-yellow-500/20 text-yellow-400',
                'Desenquadrado': 'bg-red-500/20 text-red-400',
                'Aguardando Ativos': 'bg-slate-600/50 text-slate-400'
            };
            return (
                <div className="flex flex-col items-start">
                    <span className={`px-2 py-1 text-xs font-semibold rounded-full ${styleMap[status] || styleMap['Aguardando Ativos']}`}>
                        {status}
                    </span>
                    {status !== 'Aguardando Ativos' && (
                        <span className="text-xs text-slate-400 mt-1">{deviation.toFixed(2)}% desalinhado</span>
                    )}
                </div>
            );
        };

        function Dashboard({ user, setPage, setSelectedClientId }) {
            const [clients, setClients] = useState([]);
            const [loading, setLoading] = useState(true);
            const [modalState, setModalState] = useState({ open: false, client: null });
            const [deletingClient, setDeletingClient] = useState(null);

             // UseEffect to fetch data and set up listener
            useEffect(() => {
                 // Ensure user object is loaded before fetching
                if (!user || !user.uid) {
                     console.log("Dashboard: Waiting for user data...");
                     setLoading(false); // Stop loading if user is invalid
                     return;
                 }
                console.log("Dashboard: Fetching data for user:", user.uid, "Role:", user.role);

                 setLoading(true);
                 let unsubscribe = () => {}; // Initialize unsubscribe function

                 // Fetch profiles once, as they are less likely to change frequently during a session
                 db.collection('profiles').get().then(profilesSnapshot => {
                     const profilesData = profilesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                     // Set up the client query based on user role
                     let clientQuery = db.collection('clients');
                     if (user.role !== 'admin') {
                         clientQuery = clientQuery.where('consultantId', '==', user.uid);
                     }

                     // Set up the real-time listener for clients
                     unsubscribe = clientQuery.onSnapshot(querySnapshot => {
                         const clientsData = querySnapshot.docs.map(doc => {
                             const client = { id: doc.id, ...doc.data() };
                              // Find the matching profile (use cached profilesData)
                             const clientProfile = profilesData.find(p => p.id === client.profileId);
                              // Calculate status
                             const { status, deviation } = calculateFrameworkStatus(client.portfolioData, clientProfile);
                             return { ...client, status, deviation };
                         });
                         setClients(clientsData);
                         setLoading(false); // Set loading to false after data is processed
                         console.log("Dashboard: Clients updated", clientsData.length);
                     }, (error) => {
                          // Handle errors from the real-time listener
                         console.error("Error fetching clients snapshot:", error);
                         setLoading(false);
                     });

                 }).catch(error => {
                      // Handle errors fetching the initial profiles
                     console.error("Error fetching initial profiles:", error);
                     setLoading(false);
                 });

                  // Cleanup function to unsubscribe when component unmounts or user changes
                 return () => {
                     console.log("Dashboard: Unsubscribing client listener.");
                     unsubscribe();
                 };
            }, [user]); // Re-run effect if user object changes


            const viewClient = (clientId) => {
                setSelectedClientId(clientId);
                setPage('client');
            };

            const handleDelete = async () => {
                if(deletingClient) {
                    try {
                        await db.collection('clients').doc(deletingClient.id).delete();
                         console.log("Client deleted:", deletingClient.id);
                    } catch (error) {
                        console.error("Error deleting client:", error);
                        // Maybe show an error message to the user here
                    } finally {
                        setDeletingClient(null); // Close confirmation modal regardless of success/failure
                    }
                }
            };

            return (
                <div>
                    <div className="flex justify-between items-center mb-6">
                        <h1 className="text-3xl font-bold text-white">Dashboard de Clientes</h1>
                        <button onClick={() => setModalState({ open: true, client: null })} className="flex items-center bg-sky-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-sky-700 transition-colors">
                            <Icon path={ICONS.PLUS} className="h-5 w-5 mr-2" />
                            Novo Cliente
                        </button>
                    </div>
                    {loading ? <div className="text-center p-8"><Loader className="h-8 w-8 text-sky-400 mx-auto" /></div> : (
                        <div className="bg-slate-800 rounded-xl shadow-lg overflow-x-auto"> {/* Added overflow-x-auto */}
                            <table className="w-full text-left min-w-[700px]"> {/* Added min-width */}
                                <thead className="border-b border-slate-700">
                                    <tr>
                                        <th className="p-4 text-sm font-semibold text-slate-300">Nome do Cliente</th>
                                        <th className="p-4 text-sm font-semibold text-slate-300">Perfil</th>
                                        {user?.role === 'admin' && <th className="p-4 text-sm font-semibold text-slate-300">Consultor</th>}
                                        <th className="p-4 text-sm font-semibold text-slate-300">Status</th>
                                        <th className="p-4 text-sm font-semibold text-slate-300 text-right">Ações</th>
                                    </tr>
                                </thead>
                                {/* Removed potential whitespace before tbody content */}
                                <tbody>{
                                    clients.length > 0 ? clients.map(client => (
                                        <tr key={client.id} className="border-b border-slate-700 last:border-b-0 hover:bg-slate-700/50 transition-colors">
                                            <td className="p-4 font-medium text-white">{client.name}</td>
                                            <td className="p-4 text-slate-300">{client.profileName || 'Não definido'}</td>
                                            {user?.role === 'admin' && <td className="p-4 text-slate-300">{client.consultantName}</td>}
                                            <td className="p-4">
                                                <StatusBadge status={client.status} deviation={client.deviation} />
                                            </td>
                                            <td className="p-4 flex justify-end items-center space-x-4 whitespace-nowrap"> {/* Added whitespace-nowrap */}
                                                <button onClick={() => viewClient(client.id)} className="text-sky-400 hover:text-sky-300 font-semibold">Visualizar</button>
                                                <button onClick={() => setModalState({ open: true, client: client })} className="text-slate-400 hover:text-white"><Icon path={ICONS.EDIT} className="h-5 w-5"/></button>
                                                <button onClick={() => setDeletingClient(client)} className="text-slate-400 hover:text-red-400"><Icon path={ICONS.TRASH} className="h-5 w-5"/></button>
                                            </td>
                                        </tr>
                                    )) : (
                                        <tr><td colSpan={user?.role === 'admin' ? 5 : 4} className="text-center p-8 text-slate-400">Nenhum cliente encontrado.</td></tr>
                                    )
                                }</tbody>
                            </table>
                        </div>
                    )}
                    {modalState.open && user && <ClientModal user={user} clientToEdit={modalState.client} onClose={() => setModalState({ open: false, client: null })} />}
                    {deletingClient && (
                        <ConfirmModal
                            title="Excluir Cliente"
                            message={`Tem certeza que deseja excluir "${deletingClient.name}"? Esta ação não pode ser desfeita.`}
                            onConfirm={handleDelete}
                            onCancel={() => setDeletingClient(null)}
                        />
                    )}
                </div>
            );
        }

        function ClientModal({ user, clientToEdit, onClose }) {
            const [clientName, setClientName] = useState('');
            const [profileId, setProfileId] = useState('');
            const [consultantId, setConsultantId] = useState('');

            const [profiles, setProfiles] = useState([]);
            const [consultants, setConsultants] = useState([]);
            const [loading, setLoading] = useState(false);
            const [loadingData, setLoadingData] = useState(true); // Separate loading state for initial data fetch

             // Effect to set initial form values
            useEffect(() => {
                if(clientToEdit){
                    setClientName(clientToEdit.name || '');
                    setProfileId(clientToEdit.profileId || '');
                    setConsultantId(clientToEdit.consultantId || '');
                } else if (user?.role === 'consultant') {
                     // Pre-select current consultant only for NEW clients
                    setConsultantId(user.uid);
                } else {
                     // Reset for new client as admin
                    setClientName('');
                    setProfileId('');
                    setConsultantId('');
                }
            }, [clientToEdit, user]); // Depend on clientToEdit to reset form for new vs edit

             // Effect to fetch profiles and consultants
            useEffect(() => {
                 if (!user) return; // Don't fetch if user isn't loaded
                 setLoadingData(true);
                 const fetchInitialData = async () => {
                     try {
                         const profilesSnapshot = await db.collection('profiles').get();
                         setProfiles(profilesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));

                         if (user.role === 'admin') {
                             const consultantsSnapshot = await db.collection('users').where('role', '==', 'consultant').get();
                             setConsultants(consultantsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                         }
                     } catch (error) {
                         console.error("Error fetching modal data:", error);
                          // Handle error appropriately, maybe show a message
                     } finally {
                         setLoadingData(false);
                     }
                 };
                 fetchInitialData();
            }, [user]); // Fetch only when user object is available/changes

            const handleSubmit = async (e) => {
                e.preventDefault();
                // Basic validation
                if (!clientName || !profileId || (user.role === 'admin' && !consultantId)) {
                   alert("Por favor, preencha todos os campos obrigatórios.");
                   return;
                }

                setLoading(true);

                const selectedProfile = profiles.find(p => p.id === profileId);
                let selectedConsultant;
                if (user.role === 'admin') {
                    selectedConsultant = consultants.find(c => c.id === consultantId);
                } else {
                     // For consultants, always use their own ID and name
                    selectedConsultant = { id: user.uid, name: user.name };
                }

                 // Ensure we have consultant data before proceeding
                if (!selectedConsultant) {
                   console.error("Consultant data not found.");
                   alert("Erro ao encontrar dados do consultor. Tente novamente.");
                   setLoading(false);
                   return;
                }


                const clientData = {
                    name: clientName,
                    profileId: profileId,
                    profileName: selectedProfile?.name || '', // Ensure profileName is set
                    consultantId: selectedConsultant.id,
                    consultantName: selectedConsultant.name, // Ensure consultantName is set
                };

                try {
                    if(clientToEdit) {
                         // Update existing client
                        await db.collection('clients').doc(clientToEdit.id).update(clientData);
                         console.log("Client updated:", clientToEdit.id);
                    } else {
                         // Add new client with createdAt timestamp
                        await db.collection('clients').add({...clientData, createdAt: serverTimestamp()});
                         console.log("Client added:", clientData.name);
                    }
                    onClose(); // Close modal on success
                } catch (error) {
                    console.error("Error saving client:", error);
                    alert("Erro ao salvar cliente. Tente novamente."); // Show error to user
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50">
                    <div className="bg-slate-800 rounded-xl shadow-2xl p-8 w-full max-w-lg">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-2xl font-bold text-white">{clientToEdit ? 'Editar Cliente' : 'Adicionar Novo Cliente'}</h2>
                            <button onClick={onClose} className="text-slate-400 hover:text-white"><Icon path={ICONS.CLOSE} /></button>
                        </div>
                         {loadingData ? <Loader className="h-6 w-6 mx-auto text-sky-400"/> : (
                             <form onSubmit={handleSubmit} className="space-y-4">
                                 <input type="text" placeholder="Nome do Cliente" value={clientName} onChange={e => setClientName(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-sky-500" required />
                                 <select value={profileId} onChange={e => setProfileId(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-sky-500" required>
                                     <option value="">Selecione um Perfil</option>
                                     {profiles.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}
                                 </select>
                                 {user?.role === 'admin' && (
                                     <select value={consultantId} onChange={e => setConsultantId(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-sky-500" required>
                                         <option value="">Atribuir a um Consultor</option>
                                         {consultants.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                                     </select>
                                 )}
                                 <div className="flex justify-end pt-4 space-x-3">
                                     <button type="button" onClick={onClose} className="px-4 py-2 bg-slate-600 rounded-lg hover:bg-slate-500">Cancelar</button>
                                     <button type="submit" disabled={loading} className="px-4 py-2 bg-sky-600 rounded-lg hover:bg-sky-700 disabled:bg-sky-800 flex items-center">
                                         {loading && <Loader className="h-5 w-5 mr-2" />}
                                         Salvar Cliente
                                     </button>
                                 </div>
                             </form>
                         )}
                    </div>
                </div>
            );
        }


        function ClientDetail({ clientId, user, setPage }) {
            const [client, setClient] = useState(null);
            const [profile, setProfile] = useState(null);
            const [recommendedAssets, setRecommendedAssets] = useState([]);
            const [loading, setLoading] = useState(true);
            const [activeTab, setActiveTab] = useState('consolidada');
            const [portfolio, setPortfolio] = useState([]);
            const [presentationMode, setPresentationMode] = useState(false);
            const [observations, setObservations] = useState('');

            const [redemptions, setRedemptions] = useState({}); // Stores { [assetId]: { amount, asset } }
            const [applications, setApplications] = useState({}); // Stores { [institution]: [{ name, value, Classe }, ...] }
            const [quotations, setQuotations] = useState({}); // Stores { [assetId]: quotedValue }


            useEffect(() => {
                if(!clientId) return;
                setLoading(true); // Start loading when clientId changes

                 // Fetch recommended assets (runs once or when clientId changes)
                const fetchRecommendedAssets = async () => {
                    try {
                        const snapshot = await db.collection("recommendedAssets").get();
                        const assetsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setRecommendedAssets(assetsData);
                    } catch (error) {
                        console.error("Error fetching recommended assets:", error);
                    }
                };
                fetchRecommendedAssets();

                 // Set up listener for the specific client document
                const unsubscribe = db.collection("clients").doc(clientId).onSnapshot(async (doc) => {
                    if (doc.exists) {
                        const clientData = { id: doc.id, ...doc.data() };
                        setClient(clientData);
                        // Ensure portfolioData is always an array
                        const currentPortfolio = Array.isArray(clientData.portfolioData) ? clientData.portfolioData : [];
                        setPortfolio(currentPortfolio);
                        setObservations(clientData.observations || '');

                         // Fetch associated profile
                        if (clientData.profileId) {
                            try {
                                const profileDoc = await db.collection("profiles").doc(clientData.profileId).get();
                                setProfile(profileDoc.exists ? {id: profileDoc.id, ...profileDoc.data()} : null);
                            } catch (error) {
                                console.error("Error fetching profile:", error);
                                setProfile(null);
                            }
                        } else {
                            setProfile(null);
                        }
                    } else {
                         // Client not found, reset state
                        console.warn("Client document not found for ID:", clientId);
                        setClient(null);
                        setPortfolio([]);
                        setProfile(null);
                        setObservations('');
                         // Maybe redirect back to dashboard or show a "not found" message
                         // setPage('dashboard');
                    }
                    setLoading(false); // Stop loading after client data (and profile) are processed
                }, (error) => {
                     // Handle errors listening to the client document
                    console.error("Error listening to client document:", error);
                    setClient(null);
                    setPortfolio([]);
                    setProfile(null);
                    setLoading(false);
                });

                 // Cleanup listener on unmount or clientId change
                return () => unsubscribe();
            }, [clientId]); // Dependency array includes clientId


            const portfolioAnalysis = useMemo(() => {
                if (!portfolio || portfolio.length === 0) return null;

                const totalValue = portfolio.reduce((sum, asset) => sum + (asset.Valor || 0), 0);
                const institutions = [...new Set(portfolio.map(p => {
                    return p.Instituição + (p["Número da Conta"] ? ` - ${p["Número da Conta"]}` : '');
                }))];

                 // Group by Class + Subclass for allocation comparison
                const currentAllocationByClass = portfolio.reduce((acc, asset) => {
                    const key = asset.Classe + (asset.Subclasse ? ` - ${asset.Subclasse}` : '');
                    if (!acc[key]) {
                        acc[key] = { value: 0, percentage: 0 };
                    }
                    acc[key].value += (asset.Valor || 0);
                    return acc;
                }, {});
                Object.keys(currentAllocationByClass).forEach(key => {
                    currentAllocationByClass[key].percentage = totalValue > 0 ? currentAllocationByClass[key].value / totalValue : 0;
                });

                 // Group by Issuer
                const issuerConcentration = portfolio.reduce((acc, asset) => {
                    const key = asset.Emissor || 'Não Especificado';
                    if(!acc[key]) acc[key] = 0;
                    acc[key] += (asset.Valor || 0);
                    return acc;
                }, {});

                 // Group by Asset Type
                const allocationByAssetType = portfolio.reduce((acc, asset) => {
                    const key = asset['Tipo de Ativo'] || 'Não Especificado';
                    if (!acc[key]) acc[key] = { value: 0, assets: [] };
                    acc[key].value += (asset.Valor || 0);
                    acc[key].assets.push(asset);
                    return acc;
                }, {});
                Object.keys(allocationByAssetType).forEach(key => {
                    allocationByAssetType[key].percentage = totalValue > 0 ? allocationByAssetType[key].value / totalValue : 0;
                });

                // --- NEW: Calculate Liquidity Buckets ---
                const today = new Date();
                const liquidityBuckets = {
                   'D-0': { value: 0, label: 'Hoje ou Vencido' },
                   'D-5': { value: 0, label: 'Até 5 dias' },
                   'D-30': { value: 0, label: '6 a 30 dias' },
                   'D-180': { value: 0, label: '31 a 180 dias' },
                   'D-365': { value: 0, label: '181 a 365 dias' },
                   'D+365': { value: 0, label: 'Acima de 365 dias' }
                };

                portfolio.forEach(asset => {
                    const maturityDate = parseDate(asset.Vencimento);
                    let bucketKey = 'D-5'; // Default bucket if no date

                    if (maturityDate) {
                        const daysDiff = dateDiffInDays(maturityDate, today);

                        if (daysDiff <= 0) bucketKey = 'D-0';
                        else if (daysDiff <= 5) bucketKey = 'D-5';
                        else if (daysDiff <= 30) bucketKey = 'D-30';
                        else if (daysDiff <= 180) bucketKey = 'D-180';
                        else if (daysDiff <= 365) bucketKey = 'D-365';
                        else bucketKey = 'D+365';
                    }
                    // Add value (ensure it's a number) to the determined bucket
                    liquidityBuckets[bucketKey].value += (asset.Valor || 0);
                });
                // --- End Liquidity Calculation ---


                return {
                    totalValue,
                    institutions,
                    currentAllocationByClass,
                    portfolio, // Keep original portfolio for details
                    issuerConcentration,
                    allocationByAssetType,
                    liquidityBuckets // Add liquidity data
                };
            }, [portfolio]); // Recalculate only when portfolio changes

            const totalAppliedPerClass = useMemo(() => {
                // Calculate total intended application amount per class from the 'applications' state
                return Object.values(applications).flat().reduce((acc, app) => {
                    const classKey = app.Classe; // Class key should already be 'Classe - Subclasse' or just 'Classe'
                    if (!acc[classKey]) acc[classKey] = 0;
                    acc[classKey] += app.value;
                    return acc;
                }, {});
            }, [applications]);


            const handleSaveObservations = async () => {
                if (!client) return;
                try {
                    await db.collection("clients").doc(client.id).update({
                        observations: observations
                    });
                     // Simple feedback, can be improved with a toast notification
                     // For now, removing alert as requested
                     console.log("Observações salvas com sucesso!");
                } catch (error) {
                    console.error("Error saving observations:", error);
                     // alert("Erro ao salvar as observações.");
                     console.error("Erro ao salvar as observações.");
                }
            };

            if (loading) return <div className="text-center p-8"><Loader className="h-8 w-8 text-sky-400 mx-auto" /></div>;
            if (!client) return <div className="text-center p-8 text-slate-400">Cliente não encontrado ou acesso não permitido.</div>;

            if (presentationMode) {
                 // Pass necessary data to PresentationView
                const presentationComponent = (
                    <PresentationView
                        client={client}
                        profile={profile}
                        user={user}
                        analysis={portfolioAnalysis}
                        redemptions={redemptions}
                        applications={applications}
                        quotations={quotations}
                        observations={observations}
                        onClose={() => setPresentationMode(false)}
                    />
                );
                 // Render presentation in a portal to take over the screen
                return ReactDOM.createPortal(presentationComponent, document.body);
            }

            return (
                <div className="space-y-6">
                     <button onClick={() => setPage('dashboard')} className="flex items-center text-sky-400 hover:text-sky-300 mb-4 text-sm font-semibold no-print">
                         <Icon path={ICONS.CHEVRON_LEFT} className="h-5 w-5"/>
                         Voltar para Dashboard
                     </button>
                    <div className="flex flex-wrap gap-4 justify-between items-start no-print"> {/* Added flex-wrap and gap */}
                        <div>
                            <h1 className="text-3xl font-bold text-white">{client.name}</h1>
                            <p className="text-slate-400">Perfil: <span className="font-semibold text-slate-300">{client.profileName || 'Não Definido'}</span></p>
                        </div>
                       <PortfolioUploader client={client} />
                    </div>

                    <div className="flex flex-wrap gap-x-6 gap-y-2 justify-between items-center border-b border-slate-700 no-print"> {/* Added flex-wrap and gaps */}
                        <nav className="flex flex-wrap space-x-1 sm:space-x-6"> {/* Added flex-wrap */}
                            <TabButton name="Consolidada" id="consolidada" activeTab={activeTab} setActiveTab={setActiveTab} />
                            <TabButton name="Comparativo" id="comparativo" activeTab={activeTab} setActiveTab={setActiveTab} disabled={!portfolioAnalysis || !profile}/>
                             {/* Add Liquidez Tab */}
                             <TabButton name="Liquidez" id="liquidez" activeTab={activeTab} setActiveTab={setActiveTab} disabled={!portfolioAnalysis}/>
                            <TabButton name="Emissores" id="emissores" activeTab={activeTab} setActiveTab={setActiveTab} disabled={!portfolioAnalysis} />
                            <TabButton name="Rebalanceamento" id="rebalanceamento" activeTab={activeTab} setActiveTab={setActiveTab} disabled={!portfolioAnalysis || !profile} />
                            <TabButton name="Cotação" id="cotacao" activeTab={activeTab} setActiveTab={setActiveTab} disabled={Object.keys(redemptions).length === 0} />
                        </nav>
                        <button onClick={() => setPresentationMode(true)} disabled={!portfolioAnalysis || !profile} className="flex items-center bg-teal-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-teal-700 transition-colors disabled:bg-teal-800 disabled:cursor-not-allowed mt-2 sm:mt-0"> {/* Margin top for smaller screens */}
                            <Icon path={ICONS.CHART} className="h-5 w-5 mr-2" />
                            Apresentação
                        </button>
                    </div>

                    <div className="no-print">
                        {/* Render active tab content */}
                        {activeTab === 'consolidada' && <ConsolidatedView analysis={portfolioAnalysis} />}
                        {activeTab === 'comparativo' && <ComparisonView analysis={portfolioAnalysis} profile={profile} />}
                         {/* Render Liquidity View */}
                        {activeTab === 'liquidez' && <LiquidityView analysis={portfolioAnalysis} />}
                        {activeTab === 'emissores' && <IssuerView analysis={portfolioAnalysis} />}
                        {activeTab === 'rebalanceamento' && (
                            <RebalanceWorkspace
                                analysis={portfolioAnalysis}
                                profile={profile}
                                redemptions={redemptions}
                                setRedemptions={setRedemptions}
                                applications={applications}
                                setApplications={setApplications}
                                recommendedAssets={recommendedAssets}
                                totalAppliedPerClass={totalAppliedPerClass}
                                observations={observations}
                                setObservations={setObservations}
                                onSaveObservations={handleSaveObservations}
                                portfolio={portfolio} // Pass portfolio for liquidity info
                            />
                         )}
                        {activeTab === 'cotacao' && (
                             <QuotationView
                                redemptions={redemptions}
                                quotations={quotations}
                                setQuotations={setQuotations}
                             />
                         )}
                    </div>
                </div>
            )
        }

        const TabButton = ({ name, id, activeTab, setActiveTab, disabled = false }) => (
            <button
                onClick={() => !disabled && setActiveTab(id)}
                disabled={disabled}
                className={`py-3 px-1 text-sm font-semibold border-b-2 transition-colors duration-200 ${
                    activeTab === id
                        ? 'border-sky-500 text-sky-400'
                        : 'border-transparent text-slate-400'
                } ${disabled ? 'opacity-50 cursor-not-allowed' : 'hover:text-white'}`}
            >
                {name}
            </button>
        );

        function PortfolioUploader({ client }) {
            const [uploading, setUploading] = useState(false);
            const [error, setError] = useState(null);
            const fileInputRef = React.useRef(null);

            const handleDownloadModelo = () => {
                const wb = XLSX.utils.book_new();

                const classes = ['Renda Fixa Pós', 'Renda Fixa Pré', 'Renda Fixa IPCA', 'Renda Variável', 'Multimercado', 'Fundos Listados', 'Exterior', 'Alternativo', 'Ações BR'];
                const assetTypes = ['Fundo de Investimento', 'CDB', 'LCI', 'LCA', 'Ações', 'FII', 'ETF', 'BDR', 'Previdência', 'Debênture', 'CRI', 'CRA', 'COE', 'Ações Int', 'ETF Int', 'RF Int'];

                const ws_listas_data = [
                    ["Instituição", "Classes", null, "Renda_Fixa_Pós", "Renda_Fixa_Pré", "Renda_Fixa_IPCA", "Renda_Variável", "Multimercado", "Fundos_Listados", "Exterior", "Alternativo", "Ações_BR"],
                    [INSTITUICOES[0], classes[0], null, 'Soberano', 'Bancário', 'Inflação', 'Long Only', 'Macro', 'FII', 'Renda Variável', 'FIDC', 'Long Biased'],
                    [INSTITUICOES[1], classes[1], null, 'Crédito Privado', null, null, 'Long Biased', 'Long & Short', 'FI Infra', 'Renda Fixa', null, 'Long Only'],
                    [INSTITUICOES[2], classes[2], null, 'Bancário', null, null, null, null, 'FI Agro', null],
                    [INSTITUICOES[3], classes[3]],
                    [INSTITUICOES[4], classes[4]],
                    [INSTITUICOES[5], classes[5]],
                    [INSTITUICOES[6], classes[6]],
                    [INSTITUICOES[7], classes[7]],
                    [INSTITUICOES[8], classes[8]],
                    [INSTITUICOES[9]],
                    [INSTITUICOES[10]],
                    [INSTITUICOES[11]],
                 ];


                const ws_listas = XLSX.utils.aoa_to_sheet(ws_listas_data);
                // Adjust column widths based on the number of columns
                ws_listas['!cols'] = Array(ws_listas_data[0].length).fill({ wch: 20 });
                ws_listas['!cols'][2] = { wch: 5 }; // Separator column

                XLSX.utils.book_append_sheet(wb, ws_listas, "LISTAS");

                const ws_tipos_data = [["Tipos de Ativos"], ...assetTypes.map(t => [t])];
                const ws_tipos = XLSX.utils.aoa_to_sheet(ws_tipos_data);
                ws_tipos['!cols'] = [{ wch: 25 }];
                XLSX.utils.book_append_sheet(wb, ws_tipos, "LISTA_TIPOS");

                if(!wb.Workbook) wb.Workbook = {};
                if(!wb.Workbook.Sheets) wb.Workbook.Sheets = [];
                // Hide the list sheets
                wb.Workbook.Sheets.push({ Name: 'LISTAS', Hidden: 1 });
                wb.Workbook.Sheets.push({ Name: 'LISTA_TIPOS', Hidden: 1 });

                // Data sheet setup
                const ws_dados_headers = ["Instituição", "Número da Conta", "Nome", "Emissor", "Vencimento", "Taxa", "Liquidez", "Valor", "Classe", "Subclasse", "Tipo de Ativo"];
                const ws_dados = XLSX.utils.aoa_to_sheet([ [], [], [null, ...ws_dados_headers] ]); // Add empty rows and headers with offset

                // Apply header style
                const headerStyle = { font: { bold: true, color: { rgb: "FFFFFF" } }, fill: { fgColor: { rgb: "0284C7" } } };
                ws_dados_headers.forEach((_, index) => {
                    const cellRef = XLSX.utils.encode_cell({ c: index + 1, r: 2 }); // Headers are in row 3 (index 2), starting col B (index 1)
                    if (ws_dados[cellRef]) ws_dados[cellRef].s = headerStyle;
                });

                // Apply data validation and formatting (starting from row 4, index 3)
                const numRows = 100; // Number of rows to apply validation
                for (let i = 3; i < 3 + numRows; i++) {
                    // B: Instituição (Dropdown)
                    ws_dados[`B${i + 1}`] = { t:'s', v:'', dv: { type: "list", formula1: 'LISTAS!$A$2:$A$13' } };
                    // F: Vencimento (Date format) - Set format, Excel will handle input validation mostly
                    ws_dados[`F${i + 1}`] = { t:'n', z: 'dd/mm/yyyy' }; // 'n' type allows number or date input
                     // G: Taxa (Text - allow flexible input like "CDI+1%", "10%", etc.)
                     ws_dados[`G${i + 1}`] = { t:'s' }; // General text format
                     // H: Liquidez (Text - allow "D+X", "Imediata", etc.)
                     ws_dados[`H${i + 1}`] = { t:'s' };
                     // I: Valor (Currency format)
                     ws_dados[`I${i + 1}`] = { t:'n', z: '"R$"#,##0.00_);("R$"#,##0.00)' };
                    // J: Classe (Dropdown)
                    ws_dados[`J${i + 1}`] = { t:'s', v:'', dv: { type: "list", formula1: 'LISTAS!$B$2:$B$11' } }; // Adjusted range
                    // K: Subclasse (Dependent Dropdown)
                    ws_dados[`K${i + 1}`] = { t:'s', v:'', dv: { type: "list", formula1: `INDIRECT(SUBSTITUTE(J${i + 1}," ","_"))` } }; // Depends on Classe in J
                    // L: Tipo de Ativo (Dropdown)
                    ws_dados[`L${i + 1}`] = { t:'s', v:'', dv: { type: "list", formula1: `LISTA_TIPOS!$A$2:$A$${assetTypes.length + 1}` } };
                 }

                // Define Named Ranges for dependent dropdowns (Subclasses)
                if(!wb.Workbook.Names) wb.Workbook.Names = [];
                wb.Workbook.Names.push({ Name: "Renda_Fixa_Pós", Ref: "'LISTAS'!$D$2:$D$4" }); // Adjusted range
                wb.Workbook.Names.push({ Name: "Renda_Fixa_Pré", Ref: "'LISTAS'!$E$2:$E$2" });
                wb.Workbook.Names.push({ Name: "Renda_Fixa_IPCA", Ref: "'LISTAS'!$F$2:$F$2" });
                wb.Workbook.Names.push({ Name: "Renda_Variável", Ref: "'LISTAS'!$G$2:$G$3" });
                wb.Workbook.Names.push({ Name: "Multimercado", Ref: "'LISTAS'!$H$2:$H$3" });
                wb.Workbook.Names.push({ Name: "Fundos_Listados", Ref: "'LISTAS'!$I$2:$I$4" });
                wb.Workbook.Names.push({ Name: "Exterior", Ref: "'LISTAS'!$J$2:$J$3" });
                wb.Workbook.Names.push({ Name: "Alternativo", Ref: "'LISTAS'!$K$2:$K$2" }); // Added
                wb.Workbook.Names.push({ Name: "Ações_BR", Ref: "'LISTAS'!$L$2:$L$3" }); // Added

                // Set column widths for the data sheet
                ws_dados['!cols'] = [ {wch: 2}, {wch: 20}, {wch: 20}, {wch: 35}, {wch: 20}, {wch: 15}, {wch: 15}, {wch: 15}, {wch: 20}, {wch: 20}, {wch: 20}, {wch: 25}];
                XLSX.utils.book_append_sheet(wb, ws_dados, "DADOS");

                // Write the file
                XLSX.writeFile(wb, "Planilha_Modelo_Highpar.xlsx");
            };


            const processAndUpload = (jsonData, originalFile) => {
                const cleanData = jsonData.map(row => {
                     // Robust Value Parsing
                     let numericValue = 0;
                     const rawValue = row.Valor || row.valor; // Check both casings
                     if (rawValue !== undefined && rawValue !== null && rawValue !== '') {
                         if (typeof rawValue === 'number') {
                             numericValue = rawValue;
                         } else {
                              // Remove currency symbols, thousands separators (.), replace comma decimal separator
                             const cleanedString = String(rawValue)
                                 .replace(/R\$\s?/g, '') // Remove R$ and optional space
                                 .replace(/\./g, '')       // Remove thousands separators
                                 .replace(',', '.');      // Replace comma decimal with dot
                             numericValue = parseFloat(cleanedString);
                             if (isNaN(numericValue)) {
                                 numericValue = 0; // Default to 0 if parsing fails
                                 console.warn("Could not parse 'Valor':", rawValue);
                             }
                         }
                     }


                     // Date Parsing for Vencimento
                     const parsedVencimento = parseDate(row.Vencimento);
                     const vencimentoValue = parsedVencimento
                         ? parsedVencimento.toISOString().split('T')[0] // Store as YYYY-MM-DD
                         : (row.Vencimento || ''); // Keep original if unparseable but present

                    return {
                        "Instituição": row.Instituição || '',
                        "Número da Conta": row["Número da Conta"] || '',
                        "Nome": row.Nome || '',
                        "Emissor": row.Emissor || '',
                        "Vencimento": vencimentoValue, // Store parsed date or original string
                        "Taxa": row.Taxa || '',
                        "Liquidez": row.Liquidez || '',
                        "Valor": numericValue, // Ensure Valor is a number
                        "Classe": row.Classe || '',
                        "Subclasse": row.Subclasse || '',
                        "Tipo de Ativo": row["Tipo de Ativo"] || '',
                    }
                }).filter(row => row.Instituição && row.Nome && row.Valor > 0); // Filter out rows with missing essential info or zero value

                if (cleanData.length === 0) {
                    setError("Nenhum dado válido encontrado na planilha. Verifique o preenchimento das colunas Instituição, Nome e Valor.");
                    setUploading(false);
                    return;
                }

                 // Firebase Storage Upload
                 const filePath = `portfolios/${client.id}/${Date.now()}_${originalFile.name}`; // Add timestamp to filename
                 const storageRef = storage.ref(filePath);
                 const uploadTask = storageRef.put(originalFile);

                uploadTask.on('state_changed',
                    (snapshot) => { /* Progress handling (optional) */ },
                    (uploadError) => {
                        console.error("Erro no upload para o Storage:", uploadError);
                        setError("Falha ao enviar o arquivo para o armazenamento.");
                        setUploading(false);
                    },
                    () => {
                         // Upload successful, get download URL and update Firestore
                        uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                            db.collection("clients").doc(client.id).update({
                                portfolioData: cleanData, // Save the cleaned data
                                lastPortfolioFileUrl: downloadURL, // Save the reference to the original file
                                lastUpdate: serverTimestamp() // Timestamp the update
                            }).then(() => {
                                console.log("Portfolio updated successfully for client:", client.id);
                                setError(null); // Clear any previous errors
                            }).catch((dbError) => {
                                console.error("Erro ao atualizar o Firestore:", dbError);
                                setError("Falha ao salvar os dados do portfólio no banco de dados.");
                            }).finally(() => {
                                setUploading(false); // Ensure loading stops
                            });
                        }).catch((urlError) => {
                             // Error getting download URL
                            console.error("Erro ao obter a URL de download:", urlError);
                            setError("Ocorreu um erro ao finalizar o upload (URL).");
                            setUploading(false);
                        });
                    }
                );
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                setUploading(true);
                setError(null);

                if (file.name.endsWith('.csv')) {
                    window.Papa.parse(file, {
                        header: true,
                        skipEmptyLines: 'greedy',
                         // Dynamic typing can sometimes misinterpret numbers, keep as strings initially
                        // dynamicTyping: true,
                         transformHeader: header => header.trim(), // Trim header spaces
                        complete: (results) => {
                             if (results.errors.length > 0) {
                                 console.error("CSV Parsing errors:", results.errors);
                                 setError(`Erro ao processar o CSV: ${results.errors[0].message}. Verifique a formatação.`);
                                 setUploading(false);
                             } else {
                                processAndUpload(results.data, file);
                             }
                         },
                        error: (error) => {
                             console.error("PapaParse error:", error);
                             setError("Erro crítico ao processar o arquivo CSV.");
                             setUploading(false);
                         }
                    });
                } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = e.target.result;
                            const workbook = XLSX.read(data, { type: 'array', cellDates: true }); // Ensure cellDates is true
                            const worksheet = workbook.Sheets['DADOS'];
                            if (!worksheet) {
                                setError('Aba "DADOS" não encontrada na planilha. Verifique o modelo.');
                                setUploading(false);
                                return;
                            }
                             // Use range: 2 to skip potential empty rows and start from header at row 3
                             // raw: false to get formatted strings where possible, but dates should be parsed by cellDates
                             // defval: '' to ensure empty cells become empty strings, not undefined
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { range: 2, raw: false, defval: '' });
                            processAndUpload(jsonData, file);
                        } catch (excelError) {
                            console.error("Excel processing error:", excelError);
                            setError("Erro ao processar o arquivo Excel. Verifique se não está corrompido.");
                            setUploading(false);
                        }
                    };
                    reader.onerror = (readError) => {
                        console.error("File reading error:", readError);
                        setError("Erro ao ler o arquivo do disco.");
                        setUploading(false);
                    };
                    reader.readAsArrayBuffer(file);
                } else {
                    setError("Formato de arquivo não suportado. Envie .csv, .xlsx ou .xls.");
                    setUploading(false);
                }
                 // Reset file input to allow re-uploading the same file
                event.target.value = null;
            };


            const handleDownloadLast = () => {
                if (client.lastPortfolioFileUrl) {
                    window.open(client.lastPortfolioFileUrl, '_blank');
                } else {
                     alert("Nenhum arquivo anterior foi enviado para este cliente.");
                }
            };

            return (
                 <div className="flex flex-col items-end space-y-2">
                     <div className="flex flex-wrap items-center justify-end gap-3"> {/* Use gap for spacing */}
                         <button onClick={handleDownloadModelo} className="flex items-center text-sm bg-slate-700 text-slate-300 font-semibold px-4 py-2 rounded-lg hover:bg-slate-600 transition-colors whitespace-nowrap">
                             <Icon path={ICONS.DOWNLOAD} className="h-4 w-4 mr-2" />
                             Baixar Modelo
                         </button>
                         {/* Conditionally render download last only if URL exists */}
                         {client?.lastPortfolioFileUrl && (
                             <button onClick={handleDownloadLast} className="flex items-center text-sm bg-slate-700 text-slate-300 font-semibold px-4 py-2 rounded-lg hover:bg-slate-600 transition-colors whitespace-nowrap">
                                 <Icon path={ICONS.DOWNLOAD} className="h-4 w-4 mr-2" />
                                 Baixar Último Envio
                             </button>
                         )}
                         <input type="file" accept=".csv,.xlsx,.xls" ref={fileInputRef} onChange={handleFileUpload} className="hidden" />
                         <button onClick={() => fileInputRef.current.click()} disabled={uploading} className="flex items-center bg-sky-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-sky-700 transition-colors disabled:bg-sky-800 whitespace-nowrap">
                             {uploading ? <Loader className="h-5 w-5 mr-2" /> : <Icon path={ICONS.UPLOAD} className="h-5 w-5 mr-2" />}
                             {uploading ? 'Enviando...' : 'Carregar Planilha'}
                         </button>
                     </div>
                     {error && <p className="text-xs text-red-400 text-right mt-1">{error}</p>}
                 </div>
            );
        }

        // --- NEW: Liquidity Breakdown Component (used in ConsolidatedView) ---
        function LiquidityBreakdown({ analysis }) {
            if (!analysis || !analysis.liquidityBuckets) {
                // Don't render anything if data isn't ready
                return null;
            }

            const bucketData = Object.entries(analysis.liquidityBuckets).map(([key, data]) => ({
                name: data.label,
                value: data.value,
                key: key
            }));
            const order = ['D-0', 'D-5', 'D-30', 'D-180', 'D-365', 'D+365'];
            const sortedBucketData = bucketData.sort((a, b) => order.indexOf(a.key) - order.indexOf(b.key));

            // Only render if there's actual data
            if (analysis.totalValue === 0) {
                 return <p className="text-center text-slate-500 mt-4">Liquidez não calculada (portfólio vazio).</p>;
            }

            return (
                <div className="bg-slate-800 rounded-xl shadow-lg overflow-hidden mt-6">
                    <h3 className="text-xl font-semibold text-white p-4 border-b border-slate-700">Distribuição por Liquidez</h3>
                    <div className="p-4">
                        <table className="w-full text-left">
                            <thead className="border-b border-slate-700">
                                <tr>
                                    <th className="py-2 pr-4 text-sm font-semibold text-slate-300">Prazo</th>
                                    <th className="py-2 px-4 text-sm font-semibold text-slate-300 text-right">Valor Total</th>
                                    <th className="py-2 pl-4 text-sm font-semibold text-slate-300 text-right">% da Carteira</th>
                                </tr>
                            </thead>
                            <tbody>
                                {sortedBucketData.map(bucket => (
                                    <tr key={bucket.key} className="border-b border-slate-700/50 last:border-b-0">
                                        <td className="py-2 pr-4 font-medium text-white">{bucket.name}</td>
                                        <td className="py-2 px-4 text-slate-300 text-right font-semibold">{formatCurrency(bucket.value)}</td>
                                        <td className="py-2 pl-4 text-slate-300 text-right font-semibold">
                                            {formatPercent(analysis.totalValue > 0 ? bucket.value / analysis.totalValue : 0)}
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                            <tfoot className="border-t-2 border-slate-600">
                                <tr className="font-bold">
                                    <td className="py-2 pr-4 text-white">TOTAL</td>
                                    <td className="py-2 px-4 text-slate-200 text-right">{formatCurrency(analysis.totalValue)}</td>
                                    <td className="py-2 pl-4 text-slate-200 text-right">100,00%</td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </div>
            );
        }


        // --- TAB COMPONENTS for ClientDetail ---
        function ConsolidatedView({ analysis }) {
            const [selectedInstitution, setSelectedInstitution] = useState('Todas');
            const [viewType, setViewType] = useState('estrategia');

            const groupedData = useMemo(() => {
                 if (!analysis || !analysis.portfolio) return null; // Check for portfolio existence

                let portfolioSource = analysis.portfolio;
                 // Filter portfolio if a specific institution is selected
                if (selectedInstitution !== 'Todas') {
                     portfolioSource = analysis.portfolio.filter(p => (p.Instituição + (p["Número da Conta"] ? ` - ${p["Número da Conta"]}` : '')) === selectedInstitution);
                 }

                 // Group the filtered (or full) portfolio based on view type
                const grouped = portfolioSource.reduce((acc, asset) => {
                     // Determine the key based on view type
                     const key = viewType === 'estrategia'
                         ? asset.Classe + (asset.Subclasse ? ` - ${asset.Subclasse}` : '')
                         : asset['Tipo de Ativo'] || 'Não Especificado';

                     if (!acc[key]) {
                          // Initialize group with value and assets array
                         acc[key] = { value: 0, assets: [] };
                     }
                     acc[key].value += (asset.Valor || 0); // Ensure value is added correctly
                     acc[key].assets.push(asset);
                     return acc;
                 }, {});

                 // Calculate percentage relative to the TOTAL portfolio value (not just filtered)
                return Object.entries(grouped).map(([name, data]) => ({
                    name,
                    value: data.value,
                    percentage: analysis.totalValue > 0 ? data.value / analysis.totalValue : 0,
                    assets: data.assets // Keep the assets for expansion
                })).sort((a, b) => b.value - a.value); // Sort groups by value descending

            }, [analysis, selectedInstitution, viewType]);

            if (!analysis) {
                return <div className="text-center p-10 bg-slate-800 rounded-lg"><h3 className="text-lg text-slate-400">Nenhum portfólio carregado. Por favor, carregue a planilha de ativos.</h3></div>
            }

            // Calculate total value based on selection (for display)
            const displayTotalValue = selectedInstitution === 'Todas'
               ? analysis.totalValue
               : (groupedData || []).reduce((acc, item) => acc + item.value, 0);

            return (
                <div className="space-y-6">
                    <div className="flex flex-wrap gap-4 justify-between items-start"> {/* Use flex-wrap and gap */}
                        <div className="flex-grow"> {/* Allow buttons to take space */}
                            <div className="flex items-center space-x-2 bg-slate-800 p-1 rounded-lg mb-2 w-fit">
                                <button onClick={() => setViewType('estrategia')} className={`px-3 py-1 text-xs font-semibold rounded-md ${viewType === 'estrategia' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}>Por Estratégia</button>
                                <button onClick={() => setViewType('tipo')} className={`px-3 py-1 text-xs font-semibold rounded-md ${viewType === 'tipo' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}>Por Tipo</button>
                            </div>
                            <div className="flex items-center flex-wrap gap-2 bg-slate-800 p-1 rounded-lg">
                                <button onClick={() => setSelectedInstitution('Todas')} className={`px-4 py-2 text-sm font-semibold rounded-md transition-colors ${selectedInstitution === 'Todas' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}>
                                    Todas as Contas
                                </button>
                                {analysis.institutions.map(inst => (
                                    <button key={inst} onClick={() => setSelectedInstitution(inst)} className={`px-4 py-2 text-sm font-semibold rounded-md transition-colors ${selectedInstitution === inst ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-600'}`}>
                                        {inst}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div className="bg-slate-800 p-4 rounded-lg text-right flex-shrink-0"> {/* Prevent shrinking */}
                            <p className="text-sm text-slate-400">Valor Total ({selectedInstitution === 'Todas' ? 'Consolidado' : selectedInstitution.split(' - ')[0]})</p>
                            <p className="text-2xl font-bold text-white">{formatCurrency(displayTotalValue)}</p>
                        </div>
                    </div>

                    <div className="bg-slate-800 rounded-xl shadow-lg overflow-hidden">
                       <GroupedAssetTable
                           data={groupedData || []}
                            // Pass total value of the *entire* portfolio for percentage calculation
                           totalPortfolioValue={analysis.totalValue}
                           title={viewType === 'estrategia' ? 'Classe / Subclasse' : 'Tipo de Ativo'}
                       />
                    </div>

                     {/* Display Liquidity Breakdown - RENDER THE DEFINED COMPONENT */}
                     <LiquidityBreakdown analysis={analysis} />

                </div>
            );
        }

        const FlatAssetTable = ({ portfolio }) => (
            <div className="overflow-x-auto">
                <table className="w-full text-left min-w-[800px]"> {/* Add min-width */}
                    <thead className="border-b border-slate-700">
                        <tr>
                            <th className="p-2 text-xs font-semibold text-slate-400">Nome do Ativo</th>
                            <th className="p-2 text-xs font-semibold text-slate-400">Emissor</th>
                            <th className="p-2 text-xs font-semibold text-slate-400">Tipo</th>
                            <th className="p-2 text-xs font-semibold text-slate-400">Classe / Subclasse</th>
                            <th className="p-2 text-xs font-semibold text-slate-400">Vencimento</th>
                            <th className="p-2 text-xs font-semibold text-slate-400">Taxa</th>
                            <th className="p-2 text-xs font-semibold text-slate-400">Liquidez</th>
                            <th className="p-2 text-xs font-semibold text-slate-400 text-right">Valor</th>
                        </tr>
                    </thead>
                    <tbody>
                        {portfolio.length > 0 ? portfolio.map((asset, index) => (
                            <tr key={`${asset.Nome}-${index}`} className="border-b border-slate-700/50 last:border-b-0 hover:bg-slate-700/30 text-xs"> {/* Smaller text */}
                                <td className="p-2 font-medium text-slate-100 truncate max-w-[200px]" title={asset.Nome}>{asset.Nome}</td>
                                <td className="p-2 text-slate-300 truncate max-w-[100px]" title={asset.Emissor}>{asset.Emissor || 'N/A'}</td>
                                <td className="p-2 text-slate-300">{asset['Tipo de Ativo'] || 'N/A'}</td>
                                <td className="p-2 text-slate-300">{asset.Classe}{asset.Subclasse ? ` - ${asset.Subclasse}` : ''}</td>
                                <td className="p-2 text-slate-300">{formatDisplayDate(asset.Vencimento)}</td>
                                <td className="p-2 text-slate-300">{asset.Taxa || 'N/A'}</td>
                                <td className="p-2 text-slate-300">{asset.Liquidez || 'N/A'}</td>
                                <td className="p-2 text-slate-200 text-right font-semibold whitespace-nowrap">{formatCurrency(asset.Valor)}</td>
                            </tr>
                        )) : <tr><td colSpan="8" className="p-8 text-center text-slate-400">Nenhum ativo neste grupo.</td></tr>}
                    </tbody>
                </table>
            </div>
        );

        // Modified GroupedAssetTable to accept totalPortfolioValue for correct percentages
        const GroupedAssetTable = ({ data, totalPortfolioValue, title }) => {
            const [expanded, setExpanded] = useState({});
            const toggle = (className) => setExpanded(prev => ({...prev, [className]: !prev[className]}));

            return (
                <table className="w-full text-left">
                   <thead className="border-b border-slate-700">
                        <tr>
                            <th className="p-4 text-sm font-semibold text-slate-300 w-1/2">{title}</th>
                            <th className="p-4 text-sm font-semibold text-slate-300 text-right">Valor Total</th>
                            <th className="p-4 text-sm font-semibold text-slate-300 text-right">% da Carteira Total</th>
                        </tr>
                    </thead>
                    <tbody>
                        {/* Removed potential whitespace */}
                        {data.map(group => (
                            <Fragment key={group.name}>
                                <tr className="border-b border-slate-700 last:border-b-0 hover:bg-slate-700/50 cursor-pointer" onClick={() => toggle(group.name)}>
                                    <td className="p-4 font-medium text-white flex items-center">
                                        <Icon path={expanded[group.name] ? ICONS.CHEVRON_UP : ICONS.CHEVRON_DOWN} className="h-5 w-5 mr-2 flex-shrink-0" /> {/* Added flex-shrink-0 */}
                                        <span className="truncate" title={group.name}>{group.name}</span> {/* Added truncate */}
                                    </td>
                                    <td className="p-4 text-slate-300 text-right font-semibold whitespace-nowrap">{formatCurrency(group.value)}</td>
                                    {/* Calculate percentage based on totalPortfolioValue */}
                                    <td className="p-4 text-slate-300 text-right font-semibold whitespace-nowrap">{formatPercent(totalPortfolioValue > 0 ? group.value / totalPortfolioValue : 0)}</td>
                                </tr>
                                {expanded[group.name] && (
                                    <tr className="bg-slate-800/50">
                                        <td colSpan="3" className="p-0">
                                            <div className="p-4">
                                                <FlatAssetTable portfolio={group.assets} />
                                            </div>
                                        </td>
                                    </tr>
                                )}
                            </Fragment>
                        ))}
                    </tbody>
                </table>
            );
        };


        const SvgPieChart = ({ data, title }) => {
            const COLORS = ['#0ea5e9', '#14b8a6', '#8b5cf6', '#f97316', '#ec4899', '#facc15', '#64748b', '#ef4444', '#22c55e', '#a855f7'];
            const total = data.reduce((sum, item) => sum + item.value, 0);
            if (total === 0) return (
                 <div className="bg-slate-800 p-6 rounded-xl flex flex-col h-full items-center justify-center">
                     <h3 className="text-xl font-semibold mb-4 text-white text-center">{title}</h3>
                     <p className="text-slate-400">Sem dados para exibir.</p>
                 </div>
            );

            let cumulativePercent = 0;
            const segments = data.filter(item => item.value > 0).map((item, index) => { // Filter out zero-value items
                const percent = item.value / total;
                const segment = {
                    ...item,
                    percent,
                    angle: percent * 360,
                    startAngle: cumulativePercent * 360,
                    color: COLORS[index % COLORS.length]
                };
                cumulativePercent += percent;
                return segment;
            });

            const radius = 80;
            const circumference = 2 * Math.PI * radius;

            return (
                <div className="bg-slate-800 p-6 rounded-xl flex flex-col h-full">
                    <h3 className="text-xl font-semibold mb-4 text-white text-center">{title}</h3>
                    <div className="flex-grow flex items-center justify-center min-h-[200px]"> {/* Added min-height */}
                        <svg viewBox="0 0 200 200" className="w-48 h-48 transform -rotate-90">
                            {segments.map((segment, index) => {
                                const dashArray = `${segment.percent * circumference} ${circumference}`;
                                const rotation = segment.startAngle;
                                return (
                                    <circle
                                        key={index}
                                        r={radius}
                                        cx="100"
                                        cy="100"
                                        fill="transparent"
                                        stroke={segment.color}
                                        strokeWidth="40"
                                        strokeDasharray={dashArray}
                                        transform={`rotate(${rotation} 100 100)`}
                                         style={{ '--print-color': segment.color }} /* For print fallback */
                                    >
                                        <title>{`${segment.name}: ${formatCurrency(segment.value)} (${formatPercent(segment.percent)})`}</title>
                                    </circle>
                                );
                            })}
                        </svg>
                    </div>
                    <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2 text-sm overflow-y-auto max-h-32"> {/* Allow scroll if many items */}
                        {segments.map((segment, index) => (
                            <div key={index} className="flex items-center">
                                <div className="w-3 h-3 rounded-sm mr-2 flex-shrink-0" style={{ backgroundColor: segment.color }}></div>
                                <span className="text-slate-300 truncate mr-1" title={segment.name}>{segment.name}</span>
                                <span className="ml-auto font-medium text-slate-200 whitespace-nowrap">{formatPercent(segment.percent)}</span>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };


        const CssBarChart = ({ data, title }) => {
            const COLORS = ['#0ea5e9', '#14b8a6', '#8b5cf6', '#f97316', '#ec4899', '#facc15', '#64748b', '#ef4444', '#22c55e', '#a855f7'];
            if (!data || data.length === 0) return (
                 <div className="bg-slate-800 p-6 rounded-xl">
                     <h3 className="text-xl font-semibold mb-4 text-white">{title}</h3>
                     <p className="text-slate-400">Sem dados para exibir.</p>
                 </div>
            );
            const maxValue = Math.max(...data.map(item => item.value));
            // Filter out items with 0 value for cleaner display
            const filteredData = data.filter(item => item.value > 0);
            if (filteredData.length === 0 || maxValue === 0) return (
                 <div className="bg-slate-800 p-6 rounded-xl">
                     <h3 className="text-xl font-semibold mb-4 text-white">{title}</h3>
                     <p className="text-slate-400">Sem dados significativos para exibir.</p>
                 </div>
            );

            return (
                 <div className="bg-slate-800 p-6 rounded-xl">
                     <h3 className="text-xl font-semibold mb-4 text-white">{title}</h3>
                     <div className="space-y-3">
                         {filteredData.map((item, index) => (
                             <div key={item.name + index} className="grid grid-cols-4 gap-4 items-center group">
                                 <span className="col-span-1 text-sm text-slate-300 truncate" title={item.name}>{item.name}</span>
                                 <div className="col-span-3">
                                     <div className="flex items-center">
                                         <div className="flex-grow bg-slate-700 rounded-full h-4 mr-3">
                                             <div
                                                 className="h-4 rounded-full transition-all duration-500"
                                                 style={{
                                                     width: `${(item.value / maxValue) * 100}%`,
                                                     backgroundColor: COLORS[index % COLORS.length],
                                                      '--print-color': COLORS[index % COLORS.length] /* For print fallback */
                                                 }}
                                             ></div>
                                         </div>
                                         <span className="text-sm font-semibold text-white w-28 text-right whitespace-nowrap">{formatCurrency(item.value)}</span>
                                     </div>
                                 </div>
                             </div>
                         ))}
                     </div>
                 </div>
            );
        };


        function ComparisonView({ analysis, profile }) {
            const comparisonData = useMemo(() => {
                if (!analysis || !profile || !profile.allocations) return null;

                const { totalValue, currentAllocationByClass } = analysis;

                const recommendedAllocationMap = profile.allocations.reduce((acc, alloc) => {
                    if ((alloc.subcategories || []).length > 0) {
                        alloc.subcategories.forEach(sub => {
                            const key = alloc.Classe + (sub.name ? ` - ${sub.name}` : '');
                            const normalizedKey = normalizeString(key);
                            acc[normalizedKey] = {
                                originalName: key,
                                value: (sub.percentage / 100) * totalValue,
                                percentage: sub.percentage / 100
                            };
                        });
                    } else {
                        const key = alloc.Classe;
                        const normalizedKey = normalizeString(key);
                        if(normalizedKey){
                            acc[normalizedKey] = {
                                originalName: key,
                                value: (alloc.percentage / 100) * totalValue,
                                percentage: alloc.percentage / 100
                            };
                        }
                    }
                    return acc;
                }, {});

                const currentAllocationMap = Object.keys(currentAllocationByClass).reduce((acc, key) => {
                    const normalizedKey = normalizeString(key);
                    acc[normalizedKey] = {
                        originalName: key,
                        ...currentAllocationByClass[key]
                    };
                    return acc;
                }, {});

                const allNormalizedClasses = [...new Set([...Object.keys(currentAllocationMap), ...Object.keys(recommendedAllocationMap)])];

                const comparison = allNormalizedClasses.map(normalizedClass => {
                    const current = currentAllocationMap[normalizedClass] || { value: 0, percentage: 0 };
                    const recommended = recommendedAllocationMap[normalizedClass] || { value: 0, percentage: 0 };

                    return {
                        name: current.originalName || recommended.originalName || normalizedClass,
                        currentValue: current.value,
                        recommendedValue: recommended.value,
                        currentPercent: current.percentage,
                        recommendedPercent: recommended.percentage,
                        diffValue: current.value - recommended.value,
                    };
                 // Sort primarily by recommended percentage (desc), then current (desc)
                 }).sort((a,b) => (b.recommendedPercent*1000 + b.currentPercent) - (a.recommendedPercent*1000 + a.currentPercent))
                   .filter(item => item.recommendedPercent > 0 || item.currentPercent > 0); // Keep if exists in either


                 // Chart data needs grouping only by main class
                 const currentByMainClassForChart = Object.entries(analysis.portfolio.reduce((acc, asset) => {
                     const key = asset.Classe; // Only main class
                     if(!acc[key]) acc[key] = 0;
                     acc[key] += (asset.Valor || 0);
                     return acc;
                 }, {})).map(([name, value]) => ({name, value}));

                const recommendedByMainClassChartData = profile.allocations.reduce((acc, alloc) => {
                     const key = alloc.Classe; // Only main class
                     const value = (alloc.percentage / 100) * totalValue; // Alloc % applies to main class total
                     if(!acc[key]) {
                         acc[key] = { name: key, value: 0};
                     }
                     // Sum up percentages if a main class appears multiple times (shouldn't happen with good profile setup)
                     acc[key].value += value;
                     return acc;
                 }, {});

                const institutionalData = analysis.portfolio.reduce((acc, asset) => {
                    const account = asset.Instituição + (asset["Número da Conta"] ? ` - ${asset["Número da Conta"]}` : '');
                    if (!acc[account]) acc[account] = 0;
                    acc[account] += (asset.Valor || 0);
                    return acc;
                }, {});

                return {
                    comparison,
                    currentChartData: currentByMainClassForChart, // Use main class grouped data
                    recommendedChartData: Object.values(recommendedByMainClassChartData).filter(d => d.value > 0),
                    institutionalChartData: Object.entries(institutionalData).map(([name, value]) => ({ name, value })).filter(d => d.value > 0)
                };
            }, [analysis, profile]);

            if (!comparisonData) {
                return (
                    <div className="text-center p-10 bg-slate-800 rounded-lg">
                        <h3 className="text-lg text-slate-400">Dados insuficientes para comparação.</h3>
                        <p className="text-slate-500 mt-2">Carregue um portfólio e verifique se um perfil de investidor está atribuído a este cliente.</p>
                    </div>
                );
            }

            return (
                <div className="space-y-8">
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <SvgPieChart data={comparisonData.currentChartData} title="Carteira Atual (por Classe)" />
                        <SvgPieChart data={comparisonData.recommendedChartData} title="Carteira Recomendada (por Classe)" />
                    </div>

                    <div className="bg-slate-800 rounded-xl shadow-lg overflow-hidden">
                        <h3 className="text-xl font-semibold text-white p-4">Análise Detalhada de Enquadramento</h3>
                        <div className="overflow-x-auto">
                            <table className="w-full text-left min-w-[700px]"> {/* Add min-width */}
                               <thead className="border-b border-slate-700">
                                    <tr>
                                        <th className="p-4 text-sm font-semibold text-slate-300">Classe / Subclasse</th>
                                        <th className="p-4 text-sm font-semibold text-slate-300 w-1/2">Alocação Atual vs. Recomendada</th>
                                        <th className="p-4 text-sm font-semibold text-slate-300 text-right">Ação Sugerida (R$)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {comparisonData.comparison.map((item, index) => (
                                        <tr key={item.name + index} className="border-b border-slate-700 last:border-b-0">
                                            <td className="p-4 font-medium text-white">{item.name}</td>
                                            <td className="p-4 text-slate-300">
                                                <div className="space-y-1">
                                                    <div className="flex justify-between text-xs">
                                                        <span className="font-semibold text-white">Atual: {formatPercent(item.currentPercent)}</span>
                                                        <span className="text-slate-400">Rec: {formatPercent(item.recommendedPercent)}</span>
                                                    </div>
                                                    {/* Visual Bar Representation */}
                                                     <div className="w-full bg-slate-700 rounded-full h-2.5 relative my-1">
                                                         {/* Current Allocation Bar */}
                                                         <div className="bg-sky-500 h-2.5 rounded-full" style={{ width: `${Math.min(item.currentPercent * 100, 100)}%` }}></div>
                                                         {/* Recommended Target Marker */}
                                                         <div className="absolute top-0 border-l-2 border-white h-full" style={{ left: `${item.recommendedPercent * 100}%`, top: '-2px', height: 'calc(100% + 4px)' }} title={`Recomendado: ${formatPercent(item.recommendedPercent)}`}>
                                                              {/* Optional: Add a small circle marker */}
                                                              {/* <div className="w-1 h-1 bg-white rounded-full absolute -ml-0.5 top-1/2 -translate-y-1/2"></div> */}
                                                         </div>
                                                     </div>
                                                </div>
                                            </td>
                                            <td className={`p-4 text-right font-semibold whitespace-nowrap ${
                                                 Math.abs(item.diffValue) < 1 ? 'text-slate-400' : // Negligible difference
                                                 item.diffValue > 0 ? 'text-red-400' : // Overallocated -> Resgatar
                                                 'text-green-400' // Underallocated -> Aplicar
                                             }`}>
                                                {Math.abs(item.diffValue) < 1 ? '-' : `${item.diffValue > 0 ? 'Resgatar' : 'Aplicar'} ${formatCurrency(Math.abs(item.diffValue))}`}
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <CssBarChart data={comparisonData.institutionalChartData} title="Valor por Instituição" />
                </div>
            );
        }

         // --- NEW: Liquidity View Component ---
         function LiquidityView({ analysis }) {
             if (!analysis || !analysis.liquidityBuckets) {
                 return <div className="text-center p-10 bg-slate-800 rounded-lg"><h3 className="text-lg text-slate-400">Dados de liquidez não disponíveis. Verifique os vencimentos na planilha.</h3></div>;
             }

             const bucketData = Object.entries(analysis.liquidityBuckets).map(([key, data]) => ({
                 name: data.label,
                 value: data.value,
                 key: key // Keep key for potential sorting/ordering if needed
             }));

             // Define the desired order
             const order = ['D-0', 'D-5', 'D-30', 'D-180', 'D-365', 'D+365'];
             const sortedBucketData = bucketData.sort((a, b) => order.indexOf(a.key) - order.indexOf(b.key));


             return (
                 <div className="space-y-6">
                     <h2 className="text-2xl font-bold text-white">Distribuição por Liquidez (Vencimento)</h2>
                     <CssBarChart data={sortedBucketData} title="Valor Total por Prazo de Vencimento" />

                     {/* Optional: Table view */}
                     <div className="bg-slate-800 rounded-xl shadow-lg overflow-hidden">
                         <table className="w-full text-left">
                             <thead className="border-b border-slate-700">
                                 <tr>
                                     <th className="p-4 text-sm font-semibold text-slate-300">Prazo</th>
                                     <th className="p-4 text-sm font-semibold text-slate-300 text-right">Valor Total</th>
                                     <th className="p-4 text-sm font-semibold text-slate-300 text-right">% da Carteira</th>
                                 </tr>
                             </thead>
                             <tbody>
                                 {sortedBucketData.map(bucket => (
                                     <tr key={bucket.key} className="border-b border-slate-700 last:border-b-0">
                                         <td className="p-4 font-medium text-white">{bucket.name}</td>
                                         <td className="p-4 text-slate-300 text-right font-semibold">{formatCurrency(bucket.value)}</td>
                                         <td className="p-4 text-slate-300 text-right font-semibold">
                                             {formatPercent(analysis.totalValue > 0 ? bucket.value / analysis.totalValue : 0)}
                                         </td>
                                     </tr>
                                 ))}
                             </tbody>
                             <tfoot className="border-t-2 border-slate-600 bg-slate-900/50">
                                 <tr className="font-bold">
                                     <td className="p-4 text-white">TOTAL</td>
                                     <td className="p-4 text-slate-200 text-right">{formatCurrency(analysis.totalValue)}</td>
                                     <td className="p-4 text-slate-200 text-right">100,00%</td>
                                 </tr>
                             </tfoot>
                         </table>
                     </div>
                 </div>
             );
         }


        function RebalanceWorkspace({ analysis, profile, redemptions, setRedemptions, applications, setApplications, recommendedAssets, totalAppliedPerClass, observations, setObservations, onSaveObservations, portfolio /* Pass portfolio here */ }) {

            const movements = useMemo(() => {
                 // Guard clause: Ensure necessary data is present
                if (!analysis || !analysis.portfolio || !profile || !profile.allocations) return null;

                const { totalValue, currentAllocationByClass } = analysis;

                // Build recommended map (same logic as ComparisonView)
                const recommendedAllocationMap = profile.allocations.reduce((acc, alloc) => {
                    if ((alloc.subcategories || []).length > 0) {
                        alloc.subcategories.forEach(sub => {
                            const key = alloc.Classe + (sub.name ? ` - ${sub.name}` : '');
                            const normalizedKey = normalizeString(key);
                            acc[normalizedKey] = {
                                originalName: key,
                                value: (sub.percentage / 100) * totalValue
                            };
                        });
                    } else {
                        const key = alloc.Classe;
                        const normalizedKey = normalizeString(key);
                        if(normalizedKey){
                            acc[normalizedKey] = {
                                originalName: key,
                                value: (alloc.percentage / 100) * totalValue
                            };
                        }
                    }
                    return acc;
                }, {});

                // Build current map (same logic as ComparisonView)
                const currentAllocationMap = Object.keys(currentAllocationByClass).reduce((acc, key) => {
                    const normalizedKey = normalizeString(key);
                    acc[normalizedKey] = {
                        originalName: key,
                        value: currentAllocationByClass[key].value
                    };
                    return acc;
                }, {});

                const allKeys = [...new Set([...Object.keys(currentAllocationMap), ...Object.keys(recommendedAllocationMap)])];
                const diffs = {};

                allKeys.forEach(normalizedKey => {
                    const current = currentAllocationMap[normalizedKey] || { value: 0 };
                    const recommended = recommendedAllocationMap[normalizedKey] || { value: 0 };
                    const diff = current.value - recommended.value;
                    const originalName = current.originalName || recommended.originalName;
                     // Only consider significant differences (e.g., > $1)
                    if (originalName && Math.abs(diff) > 1) {
                        diffs[originalName] = diff;
                    }
                });

                return {
                    toRedeem: Object.entries(diffs).filter(([, val]) => val > 0).reduce((acc, [key, val]) => ({...acc, [key]: val }), {}),
                    toApply: Object.entries(diffs).filter(([, val]) => val < 0).reduce((acc, [key, val]) => ({...acc, [key]: Math.abs(val) }), {}),
                };
            }, [analysis, profile]);

            // --- NEW: Calculate Funds Availability Timeline ---
            const fundsTimeline = useMemo(() => {
                 if (!redemptions || Object.keys(redemptions).length === 0) return {};

                 return Object.values(redemptions).reduce((timeline, { amount, asset }) => {
                     const days = parseLiquidityDays(asset.Liquidez);
                     if (!timeline[days]) {
                         timeline[days] = { totalAmount: 0, assets: [] };
                     }
                     timeline[days].totalAmount += amount;
                     timeline[days].assets.push({ name: asset.Nome, amount });
                     return timeline;
                 }, {});
            }, [redemptions]);

            const sortedTimelineDays = Object.keys(fundsTimeline).map(Number).sort((a, b) => a - b);
             // --- End Timeline Calculation ---


             // Handler to update redemption value, ensuring it doesn't exceed asset value
             const handleRedemptionChange = (asset, valueString) => {
                 // Create a unique ID for the specific instance of the asset in the portfolio
                 const assetId = `${asset.Instituição}-${asset["Número da Conta"] || 'noAcc'}-${asset.Nome}-${asset.Valor}`; // Use original value in ID
                 const rawValue = valueString.replace(/\D/g, ''); // Remove non-digits
                 const amount = Math.min(parseFloat(rawValue) / 100 || 0, asset.Valor); // Use original asset.Valor as max

                setRedemptions(prev => {
                     const newRedemptions = { ...prev };
                     if (amount <= 0.001) { // Use a small threshold for floating point comparison
                         delete newRedemptions[assetId]; // Remove if zero or negligible
                     } else {
                         newRedemptions[assetId] = { amount, asset };
                     }
                     return newRedemptions;
                 });
            };

            const handleAddApplication = (institution, newApp) => {
                setApplications(prev => ({
                    ...prev,
                    [institution]: [...(prev[institution] || []), newApp]
                }))
            };

            const handleDeleteApplication = (institution, index) => {
                setApplications(prev => {
                     // Check if the institution exists and has applications
                    if (!prev[institution]) return prev;
                     // Filter out the application at the specified index
                    const updatedApps = prev[institution].filter((_, i) => i !== index);
                     // If no applications left for this institution, remove the institution key
                    if (updatedApps.length === 0) {
                        const { [institution]: _, ...rest } = prev;
                        return rest;
                    } else {
                         // Otherwise, update the applications for the institution
                        return { ...prev, [institution]: updatedApps };
                    }
                });
            }

            if (!analysis || !movements) {
                return <div className="text-center p-10 bg-slate-800 rounded-lg"><h3 className="text-lg text-slate-400">Dados insuficientes para gerar sugestões de rebalanceamento (Análise ou Movimentos faltando).</h3></div>;
            }

            // Calculate total redeemed and applied *across all accounts*
            const totalRedeemedGlobally = Object.values(redemptions).reduce((sum, { amount }) => sum + amount, 0);
            const totalAppliedGlobally = Object.values(applications).flat().reduce((sum, app) => sum + app.value, 0);
            const globalCashDifference = totalRedeemedGlobally - totalAppliedGlobally;


            return (
                <div className="space-y-8">
                    {/* Observations Section */}
                    <div className="bg-slate-800 p-6 rounded-xl shadow-lg">
                        <h2 className="text-2xl font-bold text-white mb-4">Observações sobre o Plano</h2>
                        <textarea
                            className="w-full h-32 p-3 bg-slate-700 border border-slate-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-sky-500"
                            placeholder="Descreva a estratégia, os motivos das movimentações e outros pontos importantes para o cliente..."
                            value={observations}
                            onChange={(e) => setObservations(e.target.value)}
                        ></textarea>
                        <div className="text-right mt-4">
                            <button
                                onClick={onSaveObservations}
                                className="bg-sky-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-sky-700 transition-colors"
                            >
                                Salvar Observações
                            </button>
                        </div>
                    </div>

                     {/* Global Summary */}
                     <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                         <div className="bg-slate-800 p-4 rounded-lg">
                             <p className="text-sm text-slate-400">Total Resgatado (Global)</p>
                             <p className="text-xl font-semibold text-red-400">{formatCurrency(totalRedeemedGlobally)}</p>
                         </div>
                         <div className="bg-slate-800 p-4 rounded-lg">
                             <p className="text-sm text-slate-400">Total Aplicado (Global)</p>
                             <p className="text-xl font-semibold text-green-400">{formatCurrency(totalAppliedGlobally)}</p>
                         </div>
                         <div className="bg-slate-800 p-4 rounded-lg">
                             <p className="text-sm text-slate-400">Saldo Caixa (Global)</p>
                             <p className={`text-xl font-semibold ${globalCashDifference >= 0 ? 'text-sky-400' : 'text-yellow-400'}`}>
                                 {formatCurrency(globalCashDifference)}
                                 {globalCashDifference < 0 && <span className="text-xs"> (Faltando)</span>}
                             </p>
                         </div>
                     </div>


                     {/* Funds Availability Timeline */}
                     {sortedTimelineDays.length > 0 && (
                         <div className="bg-slate-800 p-6 rounded-xl shadow-lg">
                             <h2 className="text-2xl font-bold text-white mb-4 flex items-center">
                                 <Icon path={ICONS.CLOCK} className="h-6 w-6 mr-2 text-sky-400"/>
                                 Linha do Tempo (Disponibilidade de Caixa)
                             </h2>
                             <div className="space-y-3">
                                 {sortedTimelineDays.map(days => (
                                     <div key={days} className="bg-slate-700/50 p-3 rounded-lg">
                                         <p className="font-semibold text-sky-300 mb-1">
                                             {days === 0 ? 'Disponível Hoje (D+0)' : `Disponível em ${days} dia(s) (D+${days})`}:
                                             <span className="font-bold text-white ml-2">{formatCurrency(fundsTimeline[days].totalAmount)}</span>
                                         </p>
                                         <ul className="list-disc list-inside pl-2 text-xs text-slate-400">
                                             {fundsTimeline[days].assets.map((asset, idx) => (
                                                 <li key={idx} className="truncate" title={asset.name}>{asset.name}: {formatCurrency(asset.amount)}</li>
                                             ))}
                                         </ul>
                                     </div>
                                 ))}
                             </div>
                         </div>
                     )}


                    {/* Rebalance Blocks per Institution */}
                    {analysis.institutions.map(institution => (
                        <InstitutionRebalanceBlock
                            key={institution}
                            institution={institution}
                            portfolio={analysis.portfolio} // Pass full portfolio for filtering within block
                            movements={movements} // Pass calculated movements
                            redemptions={redemptions} // Pass current state
                            onRedemptionChange={handleRedemptionChange} // Pass handler
                            applications={applications} // Pass current state
                            onAddApplication={handleAddApplication} // Pass handler
                            onDeleteApplication={handleDeleteApplication} // Pass handler
                            recommendedAssets={recommendedAssets} // Pass available assets
                            totalAppliedPerClass={totalAppliedPerClass} // Pass calculated totals
                            fundsTimeline={fundsTimeline} // Pass timeline data
                        />
                    ))}
                </div>
            );
        }


        // Updated InstitutionRebalanceBlock to use portfolio prop
        function InstitutionRebalanceBlock({ institution, portfolio, movements, redemptions, onRedemptionChange, applications, onAddApplication, onDeleteApplication, recommendedAssets, totalAppliedPerClass, fundsTimeline }) {

             // Calculate totals specific to THIS institution
             const totalRedeemedInAccount = useMemo(() => {
                 return Object.values(redemptions)
                     .filter(({ asset }) => (asset.Instituição + (asset["Número da Conta"] ? ` - ${asset["Número da Conta"]}` : '')) === institution)
                     .reduce((sum, { amount }) => sum + amount, 0);
             }, [redemptions, institution]);

             const totalAppliedInAccount = useMemo(() => {
                 return (applications[institution] || []).reduce((sum, app) => sum + app.value, 0);
             }, [applications, institution]);

             const availableCash = totalRedeemedInAccount - totalAppliedInAccount;

             // Memoize the calculation of total redeemed per class within this institution
             const totalRedeemedPerClassInAccount = useMemo(() => {
                 return Object.values(redemptions)
                      // Filter for redemptions only in the current institution
                     .filter(({ asset }) => (asset.Instituição + (asset["Número da Conta"] ? ` - ${asset["Número da Conta"]}` : '')) === institution)
                      // Sum amounts per class (Class + Subclass key)
                     .reduce((acc, { asset, amount }) => {
                         const classKey = asset.Classe + (asset.Subclasse ? ` - ${asset.Subclasse}` : '');
                         if (!acc[classKey]) acc[classKey] = 0;
                         acc[classKey] += amount;
                         return acc;
                     }, {});
             }, [redemptions, institution]);


            const AssetDetailRow = ({asset}) => (
                <div className="text-xs text-slate-400 grid grid-cols-3 gap-x-2 mt-1">
                    <span>Vcto: {formatDisplayDate(asset.Vencimento)}</span>
                    <span>Taxa: {asset.Taxa || 'N/A'}</span>
                    <span>Liq.: {asset.Liquidez || 'N/A'}</span>
                </div>
            );

            return (
                <div className="bg-slate-800 p-6 rounded-xl shadow-lg">
                    <h2 className="text-2xl font-bold text-white mb-2">{institution}</h2>
                    {/* Account Summary */}
                    <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6 text-center">
                        <div className="bg-slate-700/50 p-3 rounded-lg"><p className="text-sm text-slate-400">Total Resgatado</p><p className="text-lg font-semibold text-red-400">{formatCurrency(totalRedeemedInAccount)}</p></div>
                        <div className="bg-slate-700/50 p-3 rounded-lg"><p className="text-sm text-slate-400">Total Aplicado</p><p className="text-lg font-semibold text-green-400">{formatCurrency(totalAppliedInAccount)}</p></div>
                        <div className="bg-slate-700/50 p-3 rounded-lg"><p className="text-sm text-slate-400">Caixa Disponível</p><p className={`text-lg font-semibold ${availableCash >= 0 ? 'text-sky-400' : 'text-yellow-400'}`}>{formatCurrency(availableCash)}</p></div>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        {/* Redemption Section */}
                        <div className="space-y-4">
                            <h3 className="text-xl font-semibold text-red-400 border-b border-slate-700 pb-2">Sugestões de Resgate</h3>
                             {Object.entries(movements.toRedeem).length === 0 && <p className="text-slate-400 text-sm italic">Nenhum resgate sugerido para esta conta.</p>}
                            {Object.entries(movements.toRedeem).map(([assetClass, suggestedAmount]) => {
                                 // Find assets belonging to this class AND this specific institution account
                                const assetsInClassAndAccount = portfolio.filter(p =>
                                    (p.Classe + (p.Subclasse ? ` - ${p.Subclasse}` : '')) === assetClass &&
                                    (p.Instituição + (p["Número da Conta"] ? ` - ${p["Número da Conta"]}` : '')) === institution
                                );

                                 // If no assets match both class and account, skip rendering this section for this class
                                if (assetsInClassAndAccount.length === 0) return null;

                                 // Calculate how much has already been marked for redemption *in this account* for this class
                                const redeemedInClassAccount = totalRedeemedPerClassInAccount[assetClass] || 0;
                                 // Calculate remaining needed globally for the class (might be covered by other accounts)
                                const remainingNeededGlobally = suggestedAmount - (Object.values(redemptions).filter(({asset}) => (asset.Classe + (asset.Subclasse ? ` - ${asset.Subclasse}` : '')) === assetClass ).reduce((sum, {amount}) => sum + amount, 0) || 0) ;


                                return (
                                    <div key={assetClass} className="bg-slate-700/50 p-3 rounded-lg">
                                        <div className="flex justify-between items-center mb-2 flex-wrap gap-1"> {/* Allow wrapping */}
                                            <h4 className="font-semibold text-white">{assetClass}</h4>
                                            {/* Show remaining needed *for this account* based on what's already selected here */}
                                            <span className="text-xs text-red-400 font-bold whitespace-nowrap">
                                                 Sugerido: {formatCurrency(suggestedAmount)} / Falta Global: {formatCurrency(Math.max(0, remainingNeededGlobally))}
                                             </span>
                                        </div>
                                        {assetsInClassAndAccount.map((asset) => {
                                             // Unique ID for this specific asset instance
                                             const assetId = `${asset.Instituição}-${asset["Número da Conta"] || 'noAcc'}-${asset.Nome}-${asset.Valor}`;
                                             const currentRedemptionAmount = redemptions[assetId]?.amount || 0;
                                             // Format value for input display (handle potential 0)
                                             const displayValue = currentRedemptionAmount > 0.001 ? formatCurrency(currentRedemptionAmount).replace(/R\$\s?/g, '') : '';

                                            return (
                                                <div key={assetId} className="space-y-1 py-2 border-b border-slate-600 last:border-b-0">
                                                    <div className="flex items-center justify-between space-x-2 flex-wrap gap-y-1"> {/* Allow wrapping */}
                                                        <div className="text-sm text-slate-300 flex-grow min-w-[150px]"> {/* Min width for asset info */}
                                                            <p className="truncate font-semibold" title={asset.Nome}>{asset.Nome}</p>
                                                            <p className="text-xs text-slate-400">Disponível: {formatCurrency(asset.Valor)}</p>
                                                        </div>
                                                        <div className="flex items-center space-x-2 flex-shrink-0">
                                                            <input
                                                                type="text"
                                                                inputMode="decimal" // Better for mobile keyboards
                                                                placeholder="R$ 0,00"
                                                                value={displayValue} // Use formatted display value
                                                                 onChange={(e) => onRedemptionChange(asset, e.target.value)} // Pass original asset
                                                                className="w-28 px-2 py-1 bg-slate-600 border border-slate-500 rounded-lg text-white text-sm text-right focus:ring-2 focus:ring-sky-500 focus:outline-none"
                                                            />
                                                            <button type="button" onClick={() => onRedemptionChange(asset, asset.Valor.toString())} className="text-xs bg-sky-600 hover:bg-sky-700 text-white font-semibold px-2 py-1 rounded-md">Total</button>
                                                        </div>
                                                    </div>
                                                    <AssetDetailRow asset={asset} />
                                                </div>
                                            )
                                        })}
                                    </div>
                                )
                            })}
                        </div>

                        {/* Application Section */}
                        <div className="space-y-4">
                            <h3 className="text-xl font-semibold text-green-400 border-b border-slate-700 pb-2">Sugestões de Aplicação</h3>
                             {Object.entries(movements.toApply).length === 0 && <p className="text-slate-400 text-sm italic">Nenhuma aplicação sugerida.</p>}
                            {Object.entries(movements.toApply).map(([assetClass, suggestedAmount]) => {
                                 // Calculate how much has already been allocated *globally* for this class
                                const appliedGloballySoFar = totalAppliedPerClass[assetClass] || 0;
                                 // Calculate how much is still needed for this class across all accounts
                                const remainingToApplyGlobally = suggestedAmount - appliedGloballySoFar;

                                // Filter applications already added *specifically for this class and institution*
                                const applicationsInClassAccount = (applications[institution] || []).filter(app => app.Classe === assetClass);
                                const appliedInClassAccount = applicationsInClassAccount.reduce((sum, app) => sum + app.value, 0);

                                 // Only show section if there's still a global need for this class
                                // or if applications have already been added for this class/account
                                if (remainingToApplyGlobally <= 1 && applicationsInClassAccount.length === 0) return null;


                                return (
                                    <div key={assetClass} className="bg-slate-700/50 p-3 rounded-lg">
                                        <div className="flex justify-between items-center mb-2 flex-wrap gap-1"> {/* Allow wrapping */}
                                            <h4 className="font-semibold text-white">{assetClass}</h4>
                                            <span className="text-xs text-green-400 font-bold whitespace-nowrap">
                                                 Sugerido: {formatCurrency(suggestedAmount)} / Falta Global: {formatCurrency(Math.max(0, remainingToApplyGlobally))}
                                             </span>
                                        </div>
                                         {/* List existing applications for this class/account */}
                                        {applicationsInClassAccount.map((app, index) => {
                                             // Find the original index in the full applications[institution] array
                                             const originalIndex = (applications[institution] || []).findIndex(a => a === app);
                                             return (
                                                 <div key={app.name + index} className="flex items-center justify-between bg-slate-600/50 p-2 rounded mb-2 text-sm">
                                                     <div>
                                                         <p className="font-semibold text-slate-100">{app.name}</p>
                                                         <p className="text-xs text-slate-300">{formatCurrency(app.value)}</p>
                                                     </div>
                                                      {/* Use originalIndex for deletion */}
                                                     <button onClick={() => handleDeleteApplication(institution, originalIndex)} className="text-red-400 hover:text-red-300"><Icon path={ICONS.TRASH} className="h-4 w-4" /></button>
                                                 </div>
                                             );
                                         })}

                                        {/* Add Application Form */}
                                        <AddApplicationForm
                                            assetClass={assetClass}
                                            institution={institution}
                                             // Pass available cash specific to this account
                                             availableCashInAccount={availableCash}
                                            onAddApplication={onAddApplication}
                                            recommendedAssets={recommendedAssets}
                                        />
                                    </div>
                                )
                            })}
                        </div>
                    </div>
                </div>
            )
        }


        // Modified AddApplicationForm to use availableCashInAccount
        function AddApplicationForm({ assetClass, institution, availableCashInAccount, onAddApplication, recommendedAssets }) {
            const [selectedAsset, setSelectedAsset] = useState('');
            const [customAssetName, setCustomAssetName] = useState('');
            const [value, setValue] = useState('');
            const [error, setError] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                setError(''); // Clear previous errors
                const rawValue = value.replace(/\D/g, '');
                const numValue = parseFloat(rawValue) / 100 || 0; // Ensure it's a number, default 0
                const assetName = selectedAsset === 'custom' ? customAssetName.trim() : selectedAsset;

                if (!assetName) {
                    setError('Selecione ou digite o nome do ativo.');
                    return;
                }
                if (numValue <= 0) {
                    setError('Insira um valor de aplicação positivo.');
                    return;
                }
                 // Check against available cash IN THIS ACCOUNT
                 if (numValue > availableCashInAccount + 0.001) { // Add small tolerance for floating point
                    setError(`Valor excede o caixa disponível nesta conta (${formatCurrency(availableCashInAccount)}).`);
                    return;
                }

                onAddApplication(institution, { name: assetName, value: numValue, Classe: assetClass });
                // Reset form
                setSelectedAsset('');
                setCustomAssetName('');
                setValue('');
                setError('');
            };

             // Format value input as currency
            const handleValueChange = (e) => {
                 const rawValue = e.target.value.replace(/\D/g, ''); // Remove non-digits
                 const num = parseFloat(rawValue) / 100;
                 if (isNaN(num) || num === 0) {
                     setValue(''); // Keep empty if zero or invalid
                 } else {
                     // Format as currency string without R$ symbol for input
                     setValue(new Intl.NumberFormat('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(num));
                 }
            };


            const filteredRecommendedAssets = useMemo(() => {
                 // Extract main class and sub class from assetClass string (e.g., "Renda Fixa - Crédito Privado")
                const [mainClass, subClass] = assetClass.split(' - ');
                 // Extract only the institution name (e.g., "XP Investimentos" from "XP Investimentos - 12345")
                const institutionName = institution.split(' - ')[0];

                return recommendedAssets.filter(asset =>
                     // Match main class (case-insensitive and normalized)
                     normalizeString(asset.class) === normalizeString(mainClass) &&
                     // Match subclass if it exists in both assetClass and the recommended asset (or if recommended asset has no subclass specified)
                     (!subClass || !asset.subclass || normalizeString(asset.subclass) === normalizeString(subClass)) &&
                     // Check if the asset is available at the specified institution
                     (asset.institutions || []).map(normalizeString).includes(normalizeString(institutionName))
                );
            }, [recommendedAssets, assetClass, institution]);

            return (
                <form onSubmit={handleSubmit} className="space-y-2 mt-3 pt-3 border-t border-slate-600/50">
                     {/* Asset Selection Dropdown or Custom Input */}
                    <div className="flex flex-col space-y-2">
                         <select
                             value={selectedAsset}
                             onChange={(e) => setSelectedAsset(e.target.value)}
                             className="w-full px-3 py-1 bg-slate-600 border border-slate-500 rounded-lg text-white text-sm focus:ring-1 focus:ring-sky-500 focus:outline-none"
                         >
                             <option value="">Selecione um ativo recomendado...</option>
                             {filteredRecommendedAssets.map(asset => (
                                 <option key={asset.id} value={asset.name}>{asset.name}</option>
                             ))}
                             <option value="custom">-- Outro Ativo --</option>
                         </select>

                         {/* Show custom input only if 'custom' is selected */}
                         {selectedAsset === 'custom' && (
                             <input
                                 type="text"
                                 placeholder="Nome do Ativo Personalizado"
                                 value={customAssetName}
                                 onChange={e => setCustomAssetName(e.target.value)}
                                 className="w-full px-3 py-1 bg-slate-600 border border-slate-500 rounded-lg text-white text-sm focus:ring-1 focus:ring-sky-500 focus:outline-none"
                                 required // Make required if custom is chosen
                             />
                         )}
                    </div>

                     {/* Value Input and Add Button */}
                    <div className="flex space-x-2">
                        <input
                            type="text"
                            inputMode="decimal" // Helps mobile keyboards
                            placeholder="R$ 0,00"
                            value={value} // Controlled input with formatted value
                            onChange={handleValueChange}
                            className="flex-1 px-2 py-1 bg-slate-600 border border-slate-500 rounded-lg text-white text-sm text-right focus:ring-1 focus:ring-sky-500 focus:outline-none"
                        />
                        <button type="submit" className="p-2 bg-sky-600 rounded-lg hover:bg-sky-500 focus:outline-none focus:ring-1 focus:ring-sky-300">
                            <Icon path={ICONS.PLUS} className="h-4 w-4 text-white"/>
                        </button>
                    </div>
                     {/* Error Message */}
                    {error && <p className="text-xs text-red-400 mt-1">{error}</p>}
                </form>
            );
        }

        function ConfirmModal({ title, message, onConfirm, onCancel }) {
            return (
                <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50">
                    <div className="bg-slate-800 rounded-xl shadow-2xl p-8 w-full max-w-md">
                        <h2 className="text-xl font-bold text-white mb-4">{title}</h2>
                        <p className="text-slate-300 mb-6">{message}</p>
                        <div className="flex justify-end pt-4 space-x-3">
                            <button type="button" onClick={onCancel} className="px-4 py-2 bg-slate-600 rounded-lg hover:bg-slate-500">
                                Cancelar
                            </button>
                            <button type="button" onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700">
                                Excluir
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // --- Settings Page and Components ---
        function SettingsPage() {
            const [activeTab, setActiveTab] = useState('profiles');
            return(
                <div>
                     <div className="flex justify-between items-center mb-6">
                         <h1 className="text-3xl font-bold text-white">Configurações</h1>
                     </div>
                     <div className="flex border-b border-slate-700 mb-6">
                         <TabButton name="Perfis de Investidor" id="profiles" activeTab={activeTab} setActiveTab={setActiveTab} />
                         <TabButton name="Ativos Recomendados" id="assets" activeTab={activeTab} setActiveTab={setActiveTab} />
                         <TabButton name="Classes de Ativos" id="classes" activeTab={activeTab} setActiveTab={setActiveTab} />
                     </div>
                     {activeTab === 'profiles' && <ProfilesSettings />}
                     {activeTab === 'assets' && <RecommendedAssetsSettings />}
                     {activeTab === 'classes' && <ClassesSettings />}
                </div>
            )
        }

        function ProfilesSettings() {
            const [profiles, setProfiles] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingProfile, setEditingProfile] = useState(null);
            const [confirmingDelete, setConfirmingDelete] = useState(null);
            const [assetClasses, setAssetClasses] = useState([]);
            const [refreshTrigger, setRefreshTrigger] = useState(0);

            useEffect(() => {
                const fetchData = async () => {
                    setLoading(true);
                    try {
                        const profilesSnapshot = await db.collection('profiles').orderBy('name').get(); // Order by name
                        const profilesData = profilesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setProfiles(profilesData);

                        const classesSnapshot = await db.collection('assetClasses').orderBy('name').get(); // Order by name
                        const classesData = classesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setAssetClasses(classesData);
                    } catch (error) {
                        console.error("Error fetching data for ProfilesSettings:", error);
                    } finally {
                        setLoading(false);
                    }
                };
                fetchData();
            }, [refreshTrigger]); // Refresh when trigger changes

            const openEditModal = (profile) => {
                setEditingProfile(profile);
                setIsModalOpen(true);
            }

            const openNewModal = () => {
                setEditingProfile(null);
                setIsModalOpen(true);
            }

            const openDeleteConfirmation = (profile) => {
                setConfirmingDelete(profile);
            };

            const handleConfirmDelete = async () => {
                if (confirmingDelete) {
                    await db.collection("profiles").doc(confirmingDelete.id).delete();
                    setConfirmingDelete(null);
                    setRefreshTrigger(t => t + 1); // Trigger refresh
                }
            };

            return (
                <div>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h2 className="text-2xl font-bold text-slate-300">Gerenciar Perfis de Investidor</h2>
                        <button onClick={openNewModal} className="flex items-center bg-sky-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-sky-700 transition-colors">
                            <Icon path={ICONS.PLUS} className="h-5 w-5 mr-2" />
                            Novo Perfil
                        </button>
                    </div>

                    <div className="space-y-4">
                        {loading ? <div className="text-center p-4"><Loader className="h-6 w-6 mx-auto text-sky-400"/></div> : profiles.map(profile => (
                            <div key={profile.id} className="bg-slate-800 p-4 rounded-lg">
                                <div className="flex justify-between items-start">
                                    <h3 className="text-lg font-semibold text-white">{profile.name}</h3>
                                    <div className="flex items-center space-x-3 flex-shrink-0"> {/* Prevent shrinking */}
                                        <button onClick={() => openEditModal(profile)} className="text-sky-400 hover:text-sky-300"><Icon path={ICONS.EDIT} className="h-5 w-5" /></button>
                                        <button onClick={() => openDeleteConfirmation(profile)} className="text-red-400 hover:text-red-300"><Icon path={ICONS.TRASH} className="h-5 w-5" /></button>
                                    </div>
                                </div>
                                <div className="mt-2 space-y-1">
                                    {(profile.allocations || []).map((alloc, i) => ( // Add default empty array
                                        <div key={i} className="bg-slate-700/50 p-2 rounded-md">
                                            <div className="flex justify-between">
                                                <span className="text-sm text-slate-200 font-semibold">{alloc.Classe}</span>
                                                <span className="text-sm text-slate-200 font-bold">{alloc.percentage}%</span>
                                            </div>
                                            {alloc.subcategories && alloc.subcategories.length > 0 && (
                                                <div className="pl-4 mt-1 border-l-2 border-slate-600">
                                                    {alloc.subcategories.map((sub, j) => (
                                                        <div key={j} className="flex justify-between text-xs text-slate-400">
                                                            <span>- {sub.name}</span>
                                                            <span>{sub.percentage}%</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                         {!loading && profiles.length === 0 && <p className="text-center text-slate-400 p-4">Nenhum perfil cadastrado.</p>}
                    </div>
                    {isModalOpen && <ProfileModal profile={editingProfile} assetClasses={assetClasses} onClose={() => { setIsModalOpen(false); setRefreshTrigger(t => t + 1); }} />}
                    {confirmingDelete && (
                        <ConfirmModal
                            title="Confirmar Exclusão"
                            message={`Tem certeza que deseja excluir o perfil "${confirmingDelete.name}"? Esta ação não pode ser desfeita.`}
                            onConfirm={handleConfirmDelete}
                            onCancel={() => setConfirmingDelete(null)}
                        />
                    )}
                </div>
            );
        }
        // ... (ProfileModal, RecommendedAssetsSettings, RecommendedAssetModal remain largely the same but ensure they use ordered data if relevant) ...
        // ... (Make sure ProfileModal also uses the ordered assetClasses list)

        // --- Recommended Assets Components ---
        function RecommendedAssetsSettings() {
             const [assets, setAssets] = useState([]);
             const [loading, setLoading] = useState(true);
             const [isModalOpen, setIsModalOpen] = useState(false);
             const [editingAsset, setEditingAsset] = useState(null);
             const [confirmingDelete, setConfirmingDelete] = useState(null);
             const [assetClasses, setAssetClasses] = useState([]);
             const [refreshTrigger, setRefreshTrigger] = useState(0);

             useEffect(() => {
                 setLoading(true);
                 const fetchData = async () => {
                     try {
                         const assetsSnapshot = await db.collection('recommendedAssets').orderBy('name').get(); // Order by name
                         setAssets(assetsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));

                         const classesSnapshot = await db.collection('assetClasses').orderBy('name').get(); // Order by name
                         setAssetClasses(classesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                     } catch (error) {
                         console.error("Error fetching data for RecommendedAssetsSettings:", error);
                     } finally {
                         setLoading(false);
                     }
                 };
                 fetchData();
             }, [refreshTrigger]);

             const openEditModal = (asset) => {
                 setEditingAsset(asset);
                 setIsModalOpen(true);
             }

             const openNewModal = () => {
                 setEditingAsset(null);
                 setIsModalOpen(true);
             }

             const openDeleteConfirmation = (asset) => {
                 setConfirmingDelete(asset);
             };

             const handleConfirmDelete = async () => {
                 if (confirmingDelete) {
                     await db.collection("recommendedAssets").doc(confirmingDelete.id).delete();
                     setConfirmingDelete(null);
                     setRefreshTrigger(t => t + 1);
                 }
             };

             return (
                  <div>
                      <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                          <h2 className="text-2xl font-bold text-slate-300">Gerenciar Ativos Recomendados</h2>
                          <button onClick={openNewModal} className="flex items-center bg-sky-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-sky-700 transition-colors">
                              <Icon path={ICONS.PLUS} className="h-5 w-5 mr-2" />
                              Novo Ativo
                          </button>
                      </div>

                      <div className="bg-slate-800 rounded-xl shadow-lg overflow-x-auto">
                          <table className="w-full text-left min-w-[700px]"> {/* Min width for table */}
                              <thead className="border-b border-slate-700">
                                  <tr>
                                      <th className="p-4 text-sm font-semibold text-slate-300">Nome do Ativo</th>
                                      <th className="p-4 text-sm font-semibold text-slate-300">Classe</th>
                                      <th className="p-4 text-sm font-semibold text-slate-300">Subclasse</th>
                                      <th className="p-4 text-sm font-semibold text-slate-300">Corretoras</th>
                                      <th className="p-4 text-sm font-semibold text-slate-300 text-right">Ações</th>
                                  </tr>
                              </thead>
                              <tbody>
                                  {loading ? (
                                      <tr><td colSpan="5" className="text-center p-8"><Loader className="h-8 w-8 text-sky-400 mx-auto" /></td></tr>
                                  ) : assets.length > 0 ? assets.map(asset => (
                                      <tr key={asset.id} className="border-b border-slate-700 last:border-b-0 hover:bg-slate-700/50">
                                          <td className="p-4 font-medium text-white">{asset.name}</td>
                                          <td className="p-4 text-slate-300">{asset.class}</td>
                                          <td className="p-4 text-slate-300">{asset.subclass || 'N/A'}</td>
                                           {/* Display institutions inline, wrap if needed */}
                                          <td className="p-4 text-slate-300 text-xs max-w-xs">{(asset.institutions || []).join(', ')}</td>
                                          <td className="p-4 flex justify-end items-center space-x-4 whitespace-nowrap">
                                              <button onClick={() => openEditModal(asset)} className="text-slate-400 hover:text-white"><Icon path={ICONS.EDIT} className="h-5 w-5"/></button>
                                              <button onClick={() => openDeleteConfirmation(asset)} className="text-slate-400 hover:text-red-400"><Icon path={ICONS.TRASH} className="h-5 w-5"/></button>
                                          </td>
                                      </tr>
                                  )) : (
                                      <tr><td colSpan="5" className="text-center p-8 text-slate-400">Nenhum ativo recomendado encontrado.</td></tr>
                                  )}
                              </tbody>
                          </table>
                      </div>
                      {isModalOpen && <RecommendedAssetModal asset={editingAsset} assetClasses={assetClasses} onClose={() => { setIsModalOpen(false); setRefreshTrigger(t => t + 1); }} />}
                      {confirmingDelete && (
                           <ConfirmModal
                               title="Confirmar Exclusão"
                               message={`Tem certeza que deseja excluir o ativo "${confirmingDelete.name}"?`}
                               onConfirm={handleConfirmDelete}
                               onCancel={() => setConfirmingDelete(null)}
                           />
                      )}
                  </div>
             );
        }

        function RecommendedAssetModal({ asset, onClose, assetClasses }) {
             const [name, setName] = useState(asset ? asset.name : '');
             const [assetClass, setAssetClass] = useState(asset ? asset.class : '');
             const [subclass, setSubclass] = useState(asset ? asset.subclass : '');
             const [institutions, setInstitutions] = useState(asset ? asset.institutions || [] : []);
             const [loading, setLoading] = useState(false);

            const availableSubclasses = useMemo(() => {
                if (!assetClass) return [];
                const selected = assetClasses.find(c => c.name === assetClass);
                 // Ensure subclasses is always an array, even if undefined in Firestore
                 return selected ? (selected.subclasses || []) : [];
             }, [assetClass, assetClasses]);

             const handleInstitutionToggle = (institution) => {
                 setInstitutions(prev =>
                     prev.includes(institution)
                         ? prev.filter(i => i !== institution)
                         : [...prev, institution]
                 );
             };

             const handleSubmit = async (e) => {
                 e.preventDefault();
                 setLoading(true);
                 // Ensure subclass is empty string if not applicable or not selected
                 const finalSubclass = availableSubclasses.length > 0 ? subclass : '';
                 const data = {
                     name: name.trim(),
                     class: assetClass,
                     subclass: finalSubclass,
                     institutions: institutions.sort() // Sort for consistency
                 };

                 try {
                     if (asset) {
                         await db.collection('recommendedAssets').doc(asset.id).update(data);
                     } else {
                         await db.collection('recommendedAssets').add(data);
                     }
                     onClose(); // Close modal on success
                 } catch (error) {
                     console.error("Error saving asset:", error);
                      // Consider showing an error message to the user
                     alert("Erro ao salvar o ativo. Verifique o console para detalhes.");
                 } finally {
                    setLoading(false);
                 }
             };

             return (
                  <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
                      <div className="bg-slate-800 rounded-xl shadow-2xl p-8 w-full max-w-lg max-h-[90vh] overflow-y-auto"> {/* Added max-h and overflow */}
                          <h2 className="text-2xl font-bold text-white mb-6">{asset ? 'Editar Ativo' : 'Novo Ativo Recomendado'}</h2>
                          <form onSubmit={handleSubmit} className="space-y-4">
                              <input type="text" placeholder="Nome do Ativo" value={name} onChange={e => setName(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:ring-sky-500 focus:border-sky-500" required />
                              <select value={assetClass} onChange={e => { setAssetClass(e.target.value); setSubclass(''); }} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:ring-sky-500 focus:border-sky-500" required>
                                  <option value="">Selecione a Classe</option>
                                  {assetClasses.map(c => <option key={c.id} value={c.name}>{c.name}</option>)}
                              </select>
                              <select value={subclass} onChange={e => setSubclass(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:ring-sky-500 focus:border-sky-500" disabled={availableSubclasses.length === 0}>
                                  <option value="">{availableSubclasses.length === 0 ? 'Nenhuma Subclasse' : 'Selecione a Subclasse (opcional)'}</option>
                                  {availableSubclasses.map(s => <option key={s} value={s}>{s}</option>)}
                              </select>

                              <div>
                                  <label className="text-sm font-semibold text-slate-300 mb-2 block">Corretoras Disponíveis</label>
                                  <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 p-3 bg-slate-700/50 rounded-lg">
                                      {INSTITUICOES.map(inst => (
                                          <label key={inst} className="flex items-center space-x-2 text-sm cursor-pointer hover:text-white">
                                              <input
                                                  type="checkbox"
                                                  checked={institutions.includes(inst)}
                                                  onChange={() => handleInstitutionToggle(inst)}
                                                  className="form-checkbox h-4 w-4 rounded bg-slate-600 border-slate-500 text-sky-500 focus:ring-sky-500 focus:ring-offset-slate-800"
                                              />
                                              <span>{inst}</span>
                                          </label>
                                      ))}
                                  </div>
                              </div>

                              <div className="flex justify-end pt-4 space-x-3">
                                  <button type="button" onClick={onClose} className="px-4 py-2 bg-slate-600 rounded-lg hover:bg-slate-500">Cancelar</button>
                                  <button type="submit" disabled={loading} className="px-4 py-2 bg-sky-600 rounded-lg hover:bg-sky-700 disabled:bg-sky-800 flex items-center">
                                      {loading && <Loader className="h-5 w-5 mr-2" />}
                                      Salvar
                                  </button>
                              </div>
                          </form>
                      </div>
                  </div>
             );
        }

        // --- Classes Settings Components ---
        function ClassesSettings() {
            const [classes, setClasses] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingClass, setEditingClass] = useState(null);
            const [confirmingDelete, setConfirmingDelete] = useState(null);
            const [seeding, setSeeding] = useState(false);
            const [refreshTrigger, setRefreshTrigger] = useState(0); // State to trigger re-fetch

            // Fetch data when component mounts or refreshTrigger changes
            useEffect(() => {
                setLoading(true);
                db.collection('assetClasses').orderBy('name').get() // Order by name
                    .then(snapshot => {
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setClasses(data);
                    })
                    .catch(error => {
                        console.error("Error fetching asset classes:", error);
                        // Handle error (e.g., show message)
                    })
                    .finally(() => {
                        setLoading(false);
                    });
            }, [refreshTrigger]); // Dependency array

            const handleSeedData = async () => {
                const confirmed = window.confirm("Isso adicionará classes e subclasses padrão se ainda não existirem. Deseja continuar?");
                if (!confirmed) return;

                setSeeding(true);
                const initialClasses = {
                    'Renda Fixa Pós': ['Soberano', 'Crédito Privado', 'Bancário'],
                    'Renda Fixa Pré': ['Bancário'],
                    'Renda Fixa IPCA': ['Inflação'],
                    'Renda Variável': ['Long Only', 'Long Biased'],
                    'Multimercado': ['Macro', 'Long & Short'],
                    'Fundos Listados': ['FII', 'FI Infra', 'FI Agro'],
                    'Exterior': ['Renda Variável', 'Renda Fixa'],
                    'Alternativo': ['FIDC'], // Added
                    'Ações BR': ['Long Biased', 'Long Only'], // Added
                };

                try {
                    const batch = db.batch();
                    const currentClassesSnapshot = await db.collection('assetClasses').get();
                    const currentClassNames = new Set(currentClassesSnapshot.docs.map(doc => doc.data().name));
                    let addedCount = 0;

                    Object.entries(initialClasses).forEach(([name, subclasses]) => {
                        if (!currentClassNames.has(name)) {
                            const docRef = db.collection('assetClasses').doc(); // Auto-generate ID
                            batch.set(docRef, { name, subclasses: subclasses.sort() });
                            addedCount++;
                        }
                    });

                    if (addedCount > 0) {
                        await batch.commit();
                        console.log(`Seeded ${addedCount} new asset classes.`);
                        setRefreshTrigger(t => t + 1); // Trigger re-fetch after seeding
                    } else {
                        console.log("No new classes to seed.");
                         alert("Nenhuma nova classe padrão para adicionar.");
                    }
                } catch (error) {
                    console.error("Error seeding data:", error);
                     alert("Erro ao pré-cadastrar classes.");
                } finally {
                    setSeeding(false);
                }
            };

            const handleDelete = async () => {
                if (confirmingDelete) {
                    try {
                        await db.collection('assetClasses').doc(confirmingDelete.id).delete();
                        setRefreshTrigger(t => t + 1); // Trigger re-fetch after delete
                    } catch (error) {
                        console.error("Error deleting class:", error);
                         alert("Erro ao excluir classe.");
                    } finally {
                        setConfirmingDelete(null); // Close modal
                    }
                }
            };

            return (
                <div>
                    <div className="flex flex-wrap gap-4 justify-between items-center mb-6">
                        <h2 className="text-2xl font-bold text-slate-300">Gerenciar Classes e Subclasses</h2>
                        <div className="flex items-center space-x-4">
                            <button onClick={handleSeedData} disabled={seeding} className="flex items-center bg-indigo-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-indigo-800 disabled:cursor-not-allowed">
                                {seeding ? <Loader className="h-5 w-5 mr-2" /> : null}
                                Pré-cadastrar Padrão
                            </button>
                            <button onClick={() => { setEditingClass(null); setIsModalOpen(true); }} className="flex items-center bg-sky-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-sky-700 transition-colors">
                                <Icon path={ICONS.PLUS} className="h-5 w-5 mr-2" />
                                Nova Classe
                            </button>
                        </div>
                    </div>
                    <div className="bg-slate-800 rounded-xl shadow-lg overflow-x-auto">
                        <table className="w-full text-left min-w-[600px]"> {/* Min width */}
                            <thead className="border-b border-slate-700">
                                <tr>
                                    <th className="p-4 text-sm font-semibold text-slate-300">Classe</th>
                                    <th className="p-4 text-sm font-semibold text-slate-300">Subclasses</th>
                                    <th className="p-4 text-sm font-semibold text-slate-300 text-right">Ações</th>
                                </tr>
                            </thead>
                            <tbody>
                                {loading ? (
                                    <tr><td colSpan="3" className="text-center p-8"><Loader className="h-8 w-8 text-sky-400 mx-auto" /></td></tr>
                                ) : classes.length > 0 ? classes.map(c => (
                                    <tr key={c.id} className="border-b border-slate-700 last:border-b-0">
                                        <td className="p-4 font-bold text-white w-1/4 whitespace-nowrap">{c.name}</td>
                                        <td className="p-4 text-slate-300">
                                            <div className="flex flex-wrap gap-2">
                                                 {/* Ensure subclasses is treated as an array */}
                                                {(c.subclasses || []).map(s => <span key={s} className="text-xs bg-slate-700 px-2 py-1 rounded-full whitespace-nowrap">{s}</span>)}
                                                 {(c.subclasses || []).length === 0 && <span className="text-xs text-slate-500 italic">Nenhuma</span>}
                                            </div>
                                        </td>
                                        <td className="p-4 flex justify-end items-center space-x-4 whitespace-nowrap">
                                            <button onClick={() => { setEditingClass(c); setIsModalOpen(true);}} className="text-slate-400 hover:text-white"><Icon path={ICONS.EDIT} className="h-5 w-5"/></button>
                                            <button onClick={() => setConfirmingDelete(c)} className="text-slate-400 hover:text-red-400"><Icon path={ICONS.TRASH} className="h-5 w-5"/></button>
                                        </td>
                                    </tr>
                                )) : (
                                     <tr><td colSpan="3" className="text-center p-8 text-slate-400">Nenhuma classe cadastrada. Use 'Pré-cadastrar Padrão' ou 'Nova Classe'.</td></tr>
                                )}
                            </tbody>
                        </table>
                    </div>
                    {isModalOpen && <ClassModal assetClass={editingClass} onClose={() => { setIsModalOpen(false); setRefreshTrigger(t => t + 1); }} />}
                    {confirmingDelete && (
                        <ConfirmModal
                            title="Confirmar Exclusão"
                            message={`Tem certeza que deseja excluir a classe "${confirmingDelete.name}" e todas as suas subclasses?`}
                            onConfirm={handleDelete}
                            onCancel={() => setConfirmingDelete(null)}
                        />
                    )}
                </div>
            );
        }

        function ClassModal({ assetClass, onClose }) {
             const [name, setName] = useState(assetClass ? assetClass.name : '');
              // Ensure subclasses is always an array for state initialization
             const initialSubclasses = assetClass ? (assetClass.subclasses || []).map(s => ({id: Math.random(), name: s})) : [];
             const [subclasses, setSubclasses] = useState(initialSubclasses);
             const [loading, setLoading] = useState(false);

             const handleSubclassChange = (id, value) => {
                 setSubclasses(subs => subs.map(s => s.id === id ? {...s, name: value} : s));
             };

             const addSubclass = () => {
                  // Add only if the last one isn't empty (prevents adding many blanks)
                  if (subclasses.length === 0 || subclasses[subclasses.length - 1].name.trim() !== '') {
                      setSubclasses(subs => [...subs, { id: Math.random(), name: '' }]);
                  }
             };

             const removeSubclass = (id) => {
                 setSubclasses(subs => subs.filter(s => s.id !== id));
             };

             const handleSubmit = async (e) => {
                 e.preventDefault();
                 setLoading(true);

                 const finalSubclasses = subclasses
                     .map(s => s.name.trim()) // Get trimmed names
                     .filter(Boolean) // Remove empty strings
                     .filter((value, index, self) => self.indexOf(value) === index) // Remove duplicates
                     .sort(); // Sort alphabetically

                 const data = {
                     name: name.trim(), // Trim class name
                     subclasses: finalSubclasses
                 };

                 try {
                     if (assetClass) {
                         await db.collection('assetClasses').doc(assetClass.id).update(data);
                     } else {
                         // Check if class name already exists before adding
                         const existing = await db.collection('assetClasses').where('name', '==', data.name).get();
                         if (!existing.empty) {
                             alert(`A classe "${data.name}" já existe.`);
                             setLoading(false);
                             return;
                         }
                         await db.collection('assetClasses').add(data);
                     }
                     onClose(); // Close modal on success
                 } catch (error) {
                     console.error("Error saving asset class:", error);
                      alert("Erro ao salvar a classe. Verifique o console.");
                 } finally {
                     setLoading(false);
                 }
             };

             return (
                 <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
                      <div className="bg-slate-800 rounded-xl shadow-2xl p-8 w-full max-w-lg max-h-[90vh] overflow-y-auto"> {/* Allow scroll */}
                          <h2 className="text-2xl font-bold text-white mb-6">{assetClass ? 'Editar Classe' : 'Nova Classe de Ativo'}</h2>
                          <form onSubmit={handleSubmit} className="space-y-4">
                              <input type="text" placeholder="Nome da Classe" value={name} onChange={e => setName(e.target.value)} className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white focus:ring-sky-500 focus:border-sky-500" required />
                              <div>
                                  <h3 className="text-lg font-semibold text-white mb-2">Subclasses</h3>
                                   {/* Make subclass list scrollable if it gets long */}
                                  <div className="space-y-2 max-h-60 overflow-y-auto pr-2 border border-slate-700 rounded-md p-2">
                                      {subclasses.map((sub, index) => (
                                          <div key={sub.id} className="flex items-center space-x-2">
                                              <input
                                                 type="text"
                                                 placeholder={`Subclasse ${index + 1}`}
                                                 value={sub.name}
                                                 onChange={e => handleSubclassChange(sub.id, e.target.value)}
                                                 className="flex-1 px-3 py-1 bg-slate-600 border border-slate-500 rounded-lg text-white text-sm focus:ring-1 focus:ring-sky-500 focus:outline-none"
                                              />
                                              <button type="button" onClick={() => removeSubclass(sub.id)} className="text-red-500 hover:text-red-400 p-1 flex-shrink-0"><Icon path={ICONS.TRASH} className="h-4 w-4" /></button>
                                          </div>
                                      ))}
                                      {subclasses.length === 0 && <p className="text-sm text-slate-500 italic text-center py-2">Nenhuma subclasse adicionada.</p>}
                                  </div>
                                  <button type="button" onClick={addSubclass} className="text-sky-400 font-semibold text-sm flex items-center mt-2 hover:text-sky-300">
                                      <Icon path={ICONS.PLUS} className="h-4 w-4 mr-1"/>Adicionar Subclasse
                                  </button>
                              </div>
                              <div className="flex justify-end pt-4 space-x-3">
                                  <button type="button" onClick={onClose} className="px-4 py-2 bg-slate-600 rounded-lg hover:bg-slate-500">Cancelar</button>
                                  <button type="submit" disabled={loading} className="px-4 py-2 bg-sky-600 rounded-lg hover:bg-sky-700 disabled:bg-sky-800 flex items-center">
                                      {loading && <Loader className="h-5 w-5 mr-2" />}
                                      Salvar
                                  </button>
                              </div>
                          </form>
                      </div>
                 </div>
             )
        }


        // --- PresentationView and Slide Components ---
        // ... (SlideHeader, SlideFooter remain the same) ...
        const SlideHeader = ({ title }) => (
             <div className="slide-header-print">
                 <div className="flex items-center">
                     <Icon path={ICONS.CHART} className="h-6 w-6 text-sky-500" /> {/* Slightly smaller icon for print */}
                     <span className="ml-2 text-lg font-bold">HIGHPAR</span> {/* Slightly smaller text */}
                 </div>
                 {/* Ensure title exists and is not too long */}
                 <h2 className="text-lg font-bold text-slate-700 truncate" title={title}>{title}</h2>
             </div>
        );

        const SlideFooter = ({ clientName, slideNumber, totalSlides }) => (
             <div className="slide-footer-print">
                 <span>{clientName} | Relatório de Enquadramento | Página {slideNumber} de {totalSlides}</span>
             </div>
        );


        function PresentationView({ client, profile, user, analysis, redemptions, applications, quotations, observations, onClose }) {
            const [currentSlide, setCurrentSlide] = useState(0);

             // Dynamically build slide configuration based on available data
             const slideConfigs = useMemo(() => {
                 const configs = [];
                 configs.push({ Component: TitleSlide, props: { client, user }, title: "Capa" });

                 if (analysis) {
                     configs.push({ Component: ConsolidatedPositionSlide, props: { analysis, profile }, title: "Posição Consolidada" });
                     configs.push({ Component: AssetTypeSlide, props: { analysis }, title: "Concentração por Tipo de Ativo" });
                      // Add Liquidity Slide if analysis exists
                     configs.push({ Component: LiquiditySlide, props: { analysis }, title: "Distribuição por Liquidez"});
                 }
                 if (analysis && profile) {
                     configs.push({ Component: AllocationComparisonSlide, props: { analysis, profile }, title: "Análise de Enquadramento" });
                 }
                 if(analysis) {
                      configs.push({ Component: IssuerConcentrationSlide, props: { analysis }, title: "Concentração por Emissor" });
                 }

                  // Only add observation slide if observations exist
                 if (observations && observations.trim() !== '') {
                     configs.push({ Component: ObservationsSlide, props: { observations }, title: "Observações e Estratégia"});
                 }

                 // Add rebalancing slides only if there are movements
                 const hasRedemptions = Object.keys(redemptions).length > 0;
                 const hasApplications = Object.values(applications).flat().length > 0;

                 if (hasRedemptions || hasApplications) {
                     configs.push({ Component: RebalancePlanSlide, props: { redemptions, applications, fundsTimeline: calculateFundsTimeline(redemptions) /* Calculate timeline here */ }, title: "Plano de Ação" });
                     // Projected Portfolio Slide 1 (Summary)
                     configs.push({ Component: ProjectedPortfolioSlide, props: { analysis, redemptions, applications }, title: "Carteira Projetada - Resumo" });
                      // Projected Portfolio Slide 2 (Assets by Class) - Only if projection exists
                      const projectedAnalysis = calculateProjectedAnalysis(analysis, redemptions, applications);
                      if (projectedAnalysis && projectedAnalysis.portfolio.length > 0) {
                          configs.push({ Component: ProjectedAssetsByClassSlide, props: { projectedAnalysis }, title: "Carteira Projetada - Ativos" });
                      }
                 }

                 // Add quotation slide only if there are redemptions
                 if (hasRedemptions) {
                     configs.push({ Component: QuotationSlide, props: { redemptions, quotations }, title: "Cotação para Resgate" });
                 }

                 return configs;
             }, [client, user, analysis, profile, redemptions, applications, quotations, observations]); // Include all dependencies


            const nextSlide = () => setCurrentSlide(prev => Math.min(prev + 1, slideConfigs.length - 1));
            const prevSlide = () => setCurrentSlide(prev => Math.max(prev - 1, 0));

             // Use window.print() which should utilize the @media print styles
            const handlePrint = () => {
                 window.print();
            };

             // Helper function to calculate timeline for passing to RebalancePlanSlide
             const calculateFundsTimeline = (currentRedemptions) => {
                 if (!currentRedemptions || Object.keys(currentRedemptions).length === 0) return {};
                 return Object.values(currentRedemptions).reduce((timeline, { amount, asset }) => {
                     const days = parseLiquidityDays(asset.Liquidez);
                     if (!timeline[days]) {
                         timeline[days] = { totalAmount: 0, assets: [] };
                     }
                     timeline[days].totalAmount += amount;
                     timeline[days].assets.push({ name: asset.Nome, amount });
                     return timeline;
                 }, {});
             };

             // Helper function to calculate projected portfolio for slide generation
             const calculateProjectedAnalysis = (currentAnalysis, currentRedemptions, currentApplications) => {
                 if (!currentAnalysis) return null;
                 let projectedPortfolio = JSON.parse(JSON.stringify(currentAnalysis.portfolio)); // Deep copy
                 const redemptionMap = {};
                 Object.values(currentRedemptions).forEach(({ asset, amount }) => {
                    const assetId = `${asset.Instituição}-${asset["Número da Conta"] || 'noAcc'}-${asset.Nome}-${asset.Valor}`; // Use original value in ID
                    redemptionMap[assetId] = (redemptionMap[assetId] || 0) + amount;
                 });
                 projectedPortfolio = projectedPortfolio.map(asset => {
                    const assetId = `${asset.Instituição}-${asset["Número da Conta"] || 'noAcc'}-${asset.Nome}-${asset.Valor}`;
                    if (redemptionMap[assetId]) {
                        asset.Valor = Math.max(0, asset.Valor - redemptionMap[assetId]); // Ensure value doesn't go below 0
                     }
                    return asset;
                 }).filter(asset => asset.Valor > 0.001); // Filter out zero/negligible value assets

                 Object.entries(currentApplications).forEach(([institution, apps]) => {
                     apps.forEach(app => {
                         const [inst, conta] = institution.split(' - ');
                         projectedPortfolio.push({ /* ... new asset details ... */
                            "Instituição": inst,
                            "Número da Conta": conta || '',
                            "Nome": app.name,
                            "Valor": app.value,
                            "Classe": app.Classe.split(' - ')[0],
                            "Subclasse": app.Classe.split(' - ')[1] || '',
                            "Emissor": '', "Vencimento": '', "Taxa": '', "Liquidez": '', "Tipo de Ativo": 'Nova Aplicação',
                         });
                     });
                 });
                 const newTotalValue = projectedPortfolio.reduce((sum, asset) => sum + asset.Valor, 0);

                 // Group by main class for chart/summary
                const allocationByMainClass = projectedPortfolio.reduce((acc, asset) => {
                    const key = asset.Classe;
                    if (!acc[key]) acc[key] = { name: key, value: 0 };
                    acc[key].value += (asset.Valor || 0);
                    return acc;
                }, {});

                // Group by institution for summary
                const allocationByInstitution = projectedPortfolio.reduce((acc, asset) => {
                    const key = asset.Instituição + (asset["Número da Conta"] ? ` - ${asset["Número da Conta"]}` : '');
                    if (!acc[key]) acc[key] = { name: key, value: 0 };
                    acc[key].value += (asset.Valor || 0);
                    return acc;
                }, {});

                 return {
                     totalValue: newTotalValue,
                     chartData: Object.values(allocationByMainClass).filter(d => d.value > 0), // Data for pie chart
                     portfolio: projectedPortfolio, // Full projected portfolio
                     valuePerClass: Object.values(allocationByMainClass).filter(d => d.value > 0).sort((a,b)=>b.value-a.value), // Sorted list for table
                     valuePerInstitution: Object.values(allocationByInstitution).filter(d => d.value > 0).sort((a,b)=>b.value-a.value) // Sorted list for table
                 };
             };


            return (
                 <div className="fixed inset-0 bg-slate-900 z-[100] flex flex-col"> {/* Increased z-index */}
                    {/* Screen UI: Header */}
                    <header className="no-print p-4 bg-slate-800 flex justify-between items-center border-b border-slate-700 flex-shrink-0">
                         {/* Header content */}
                        <h2 className="font-bold text-white text-lg">Modo Apresentação</h2>
                        <div className="flex items-center space-x-4">
                            <span className="text-sm text-slate-400">Slide {currentSlide + 1} de {slideConfigs.length}</span>
                            <div className="flex items-center space-x-2">
                                <button onClick={prevSlide} disabled={currentSlide === 0} className="p-2 rounded-md bg-slate-700 hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed"><Icon path={ICONS.CHEVRON_LEFT} className="h-5 w-5" /></button>
                                <button onClick={nextSlide} disabled={currentSlide === slideConfigs.length - 1} className="p-2 rounded-md bg-slate-700 hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed"><Icon path={ICONS.CHEVRON_RIGHT} className="h-5 w-5" /></button>
                            </div>
                            <button onClick={handlePrint} className="flex items-center bg-sky-600 px-3 py-2 text-sm rounded-lg hover:bg-sky-700"><Icon path={ICONS.PDF} className="h-5 w-5 mr-2"/> Gerar PDF / Imprimir</button>
                            <button onClick={onClose} className="p-2 rounded-md bg-slate-700 hover:bg-slate-600"><Icon path={ICONS.CLOSE} className="h-5 w-5" /></button>
                        </div>
                    </header>

                    {/* Screen UI: Slide Display Area */}
                     <main className="no-print flex-1 p-4 md:p-8 overflow-hidden relative"> {/* Changed overflow */}
                         {/* Use translate to show/hide slides for smoother transition */}
                         <div className="w-full h-full relative">
                             {slideConfigs.map(({ Component, props, title }, index) => (
                                 <div
                                     key={`screen-${index}`}
                                     className={`absolute top-0 left-0 w-full h-full transition-transform duration-300 ease-in-out transform ${
                                         index === currentSlide ? 'translate-x-0' :
                                         index < currentSlide ? '-translate-x-full' : 'translate-x-full'
                                     }`}
                                     style={{ visibility: index === currentSlide ? 'visible' : 'hidden' }} // Control visibility
                                 >
                                      {/* Apply consistent styling for the slide container */}
                                      <div className="w-full h-full bg-white text-slate-900 p-6 md:p-10 border border-slate-300 rounded-lg shadow-lg flex flex-col">
                                           {/* Conditionally render header/footer for screen view if needed (can mimic print styles) */}
                                           {index > 0 && <SlideHeader title={title} />}
                                           <div className="flex-grow overflow-y-auto slide-content-print"> {/* Make content scrollable */}
                                                <Component {...props} />
                                           </div>
                                          {index > 0 && <SlideFooter clientName={client.name} slideNumber={index + 1} totalSlides={slideConfigs.length} />}
                                     </div>
                                 </div>
                             ))}
                         </div>
                    </main>


                     {/* Print UI: Render ALL slides sequentially here, hidden on screen */}
                     <div className="printable-content">
                         {slideConfigs.map(({ Component, props, title }, index) => {
                             const slideInfo = { current: index + 1, total: slideConfigs.length };
                             return (
                                  // Each slide is a page
                                 <div key={`print-${index}`} className="presentation-slide">
                                      {/* Render Header except for the title slide */}
                                     {index > 0 && <SlideHeader title={title} />}
                                      {/* Render Slide Content */}
                                     <div className="slide-content-print">
                                          {/* Use a try-catch block for safer component rendering in print */}
                                         {(() => {
                                             try {
                                                 return <Component {...props} />;
                                             } catch (error) {
                                                 console.error(`Error rendering slide ${index + 1} (${title}) for print:`, error);
                                                 return <p style={{color: 'red'}}>Erro ao renderizar este slide para impressão.</p>;
                                             }
                                         })()}
                                     </div>
                                      {/* Render Footer except for the title slide */}
                                     {index > 0 && <SlideFooter clientName={client.name} slideNumber={slideInfo.current} totalSlides={slideConfigs.length} />}
                                 </div>
                             );
                         })}
                    </div>
                 </div>
            );
        }

        // --- Slide Components ---
        const TitleSlide = ({ client, user }) => (
            <div className="text-center flex flex-col items-center justify-center h-full p-4">
                 {/* Make elements slightly smaller if needed for print */}
                <Icon path={ICONS.CHART} className="h-16 w-16 md:h-24 md:w-24 text-sky-500 mb-4 md:mb-6" />
                <h1 className="text-2xl md:text-4xl font-bold text-slate-700 mb-2 md:mb-4">HIGHPAR</h1>
                <h2 className="text-3xl md:text-5xl font-bold text-slate-900 mb-8 md:mb-12">Relatório de Enquadramento de Carteira</h2>
                <div className="text-lg md:text-xl text-slate-600 space-y-1">
                    <p className="font-bold text-xl md:text-2xl text-slate-800 mb-2 md:mb-4">{client.name}</p>
                    <p>Consultor: {user.name}</p>
                    <p>Data: {new Date().toLocaleDateString('pt-BR')}</p>
                </div>
            </div>
        );


        const ConsolidatedPositionSlide = ({ analysis, profile }) => {
            // Recalculate data specifically for this slide format if needed
            const currentByClass = useMemo(() => {
                if(!analysis) return [];
                // Group only by main class for this slide's chart
                return Object.entries(analysis.portfolio.reduce((acc, asset) => {
                    const key = asset.Classe;
                    if(!acc[key]) acc[key] = 0;
                    acc[key] += (asset.Valor || 0);
                    return acc;
                }, {})).map(([name, value]) => ({name, value}));
            }, [analysis]);

            const recommendedChartData = useMemo(() => {
                 if (!analysis || !profile || !profile.allocations) return null;
                 const { totalValue } = analysis;
                 // Group by main class
                 const data = profile.allocations.reduce((acc, alloc) => {
                     const key = alloc.Classe;
                     const value = (alloc.percentage / 100) * totalValue;
                     if(!acc[key]) { acc[key] = { name: key, value: 0}; }
                     acc[key].value += value;
                     return acc;
                 }, {});
                return Object.values(data).filter(d => d.value > 0);
            }, [analysis, profile]);

            const institutionalData = useMemo(() => {
                if (!analysis) return null;
                const data = analysis.portfolio.reduce((acc, asset) => {
                    const account = asset.Instituição + (asset["Número da Conta"] ? ` - ${asset["Número da Conta"]}` : '');
                    if (!acc[account]) acc[account] = 0;
                    acc[account] += (asset.Valor || 0);
                    return acc;
                }, {});
                return Object.entries(data).map(([name, value]) => ({ name, value })).filter(d => d.value > 0)
            }, [analysis]);

            return (
                 <React.Fragment>
                     {analysis ? (
                         <div className="flex flex-col h-full space-y-4 md:space-y-6"> {/* Reduced spacing */}
                             <div className="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6 flex-grow min-h-[300px]"> {/* Min height */}
                                 <SvgPieChart data={currentByClass} title="Distribuição por Estratégia" />
                                 <SvgPieChart data={recommendedChartData} title="Distribuição Recomendada" />
                             </div>
                             <div className="flex-shrink-0">
                                 <CssBarChart data={institutionalData} title="Valor Total por Instituição" />
                             </div>
                         </div>
                     ) : <p className="text-slate-500">Dados do portfólio não disponíveis.</p>}
                 </React.Fragment>
            );
        };


        const AllocationComparisonSlide = ({ analysis, profile }) => {
             const comparisonData = useMemo(() => {
                 if (!analysis || !profile || !profile.allocations) return null;
                 // ... (same calculation logic as in ComparisonView) ...
                 const { totalValue, currentAllocationByClass } = analysis;
                 const recommendedAllocationMap = profile.allocations.reduce((acc, alloc) => {
                    if ((alloc.subcategories || []).length > 0) {
                        alloc.subcategories.forEach(sub => {
                            const key = alloc.Classe + (sub.name ? ` - ${sub.name}` : '');
                            acc[normalizeString(key)] = { originalName: key, value: (sub.percentage / 100) * totalValue, percentage: sub.percentage / 100 };
                        });
                    } else { const key = alloc.Classe; if(key) acc[normalizeString(key)] = { originalName: key, value: (alloc.percentage / 100) * totalValue, percentage: alloc.percentage / 100 }; }
                    return acc;
                 }, {});
                 const currentAllocationMap = Object.keys(currentAllocationByClass).reduce((acc, key) => { acc[normalizeString(key)] = { originalName: key, ...currentAllocationByClass[key] }; return acc; }, {});
                 const allKeys = [...new Set([...Object.keys(currentAllocationMap), ...Object.keys(recommendedAllocationMap)])];
                 return allKeys.map(normKey => {
                    const current = currentAllocationMap[normKey] || { value: 0, percentage: 0 };
                    const recommended = recommendedAllocationMap[normKey] || { value: 0, percentage: 0 };
                    return { name: current.originalName || recommended.originalName || normKey, currentPercent: current.percentage, recommendedPercent: recommended.percentage, diffValue: current.value - recommended.value };
                 }).sort((a,b) => (b.recommendedPercent*1000 + b.currentPercent) - (a.recommendedPercent*1000 + a.currentPercent))
                   .filter(item => item.recommendedPercent > 0 || item.currentPercent > 0);
             }, [analysis, profile]);

             return (
                  <React.Fragment>
                      {!comparisonData ? <p className="text-slate-500">Dados insuficientes para comparação.</p> : (
                          <div className="overflow-y-auto h-full"> {/* Allow scrolling if table is long */}
                              <table className="w-full text-left">
                                 <thead className="border-b border-slate-300"> {/* Lighter border for print */}
                                      <tr>
                                          <th className="p-2 md:p-3 text-xs md:text-sm font-semibold text-slate-600">Classe / Subclasse</th>
                                          <th className="p-2 md:p-3 text-xs md:text-sm font-semibold text-slate-600 w-1/2">Alocação</th>
                                          <th className="p-2 md:p-3 text-xs md:text-sm font-semibold text-slate-600 text-right">Ação Sugerida</th>
                                      </tr>
                                  </thead>
                                  <tbody>
                                      {comparisonData.map((item, index) => (
                                          <tr key={index} className="border-b border-slate-200 last:border-b-0">
                                              <td className="p-2 md:p-3 font-medium text-slate-800 text-xs md:text-sm">{item.name}</td>
                                              <td className="p-2 md:p-3 text-slate-700">
                                                  <div className="space-y-1">
                                                      <div className="flex justify-between text-[10px] md:text-xs">
                                                          <span className="font-semibold text-slate-800">Atual: {formatPercent(item.currentPercent)}</span>
                                                          <span className="text-slate-500">Rec: {formatPercent(item.recommendedPercent)}</span>
                                                      </div>
                                                      <div className="w-full bg-slate-300 rounded-full h-2 md:h-2.5 relative my-1">
                                                          <div className="bg-sky-500 h-full rounded-full" style={{ width: `${Math.min(item.currentPercent * 100, 100)}%` }}></div>
                                                          <div className="absolute top-0 border-l-2 border-slate-700 h-full" style={{ left: `${item.recommendedPercent * 100}%`, top: '-1px', height: 'calc(100% + 2px)' }} title={`Recomendado: ${formatPercent(item.recommendedPercent)}`}></div>
                                                      </div>
                                                  </div>
                                              </td>
                                              <td className={`p-2 md:p-3 text-right font-semibold whitespace-nowrap text-xs md:text-sm ${ Math.abs(item.diffValue) < 1 ? 'text-slate-400' : item.diffValue > 0 ? 'text-red-500' : 'text-green-500' }`}>
                                                   {Math.abs(item.diffValue) < 1 ? '-' : formatCurrency(Math.abs(item.diffValue))}
                                              </td>
                                          </tr>
                                      ))}
                                  </tbody>
                              </table>
                          </div>
                      )}
                  </React.Fragment>
             );
        };

        const ObservationsSlide = ({ observations }) => (
            // This slide component itself remains the same,
            // its inclusion is handled in PresentationView's useMemo
             <div className="h-full flex flex-col">
                 <h3 className="text-xl md:text-2xl font-bold text-slate-800 mb-4">Observações e Estratégia</h3>
                 <div className="flex-grow bg-slate-100 p-4 md:p-6 rounded-lg text-slate-700 whitespace-pre-wrap overflow-y-auto text-sm md:text-base border border-slate-200">
                     {observations || "Nenhuma observação adicionada."}
                 </div>
             </div>
        );


        const RebalancePlanSlide = ({ redemptions, applications, fundsTimeline }) => {
            const totalRedeemed = Object.values(redemptions).reduce((sum, { amount }) => sum + amount, 0);
            const totalApplied = Object.values(applications).flat().reduce((sum, app) => sum + app.value, 0);
            const sortedTimelineDays = Object.keys(fundsTimeline).map(Number).sort((a, b) => a - b);


            return (
                 <React.Fragment>
                      {/* Check if there's anything to show */}
                      {totalRedeemed === 0 && totalApplied === 0 ? (
                          <p className="text-slate-500 text-center">Nenhum plano de rebalanceamento definido.</p>
                      ) : (
                         <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 md:gap-6 h-full">
                             {/* Redemptions */}
                             <div className="bg-slate-100 border border-slate-200 p-4 rounded-lg flex flex-col">
                                 <h3 className="text-lg md:text-xl font-semibold text-red-600 mb-3">Resgates Sugeridos</h3>
                                 <div className="space-y-2 flex-grow overflow-y-auto pr-1">
                                     {Object.values(redemptions).length > 0 ? Object.values(redemptions).map(({ asset, amount }, i) => (
                                         <div key={i} className="flex justify-between items-center text-xs md:text-sm p-2 bg-white rounded border border-slate-200">
                                             <div>
                                                 <p className="font-semibold text-slate-700 truncate" title={asset.Nome}>{asset.Nome}</p>
                                                 <p className="text-[10px] md:text-xs text-slate-500">{asset.Instituição}</p>
                                             </div>
                                             <p className="font-bold text-red-500 whitespace-nowrap">{formatCurrency(amount)}</p>
                                         </div>
                                     )) : <p className="text-slate-500 text-sm italic">Nenhum resgate necessário.</p>}
                                 </div>
                                 <div className="border-t border-slate-300 mt-3 pt-3 flex justify-between font-bold text-sm md:text-base flex-shrink-0">
                                     <span>Total Resgatado:</span>
                                     <span className="text-red-600">{formatCurrency(totalRedeemed)}</span>
                                 </div>
                             </div>

                             {/* Applications */}
                              <div className="bg-slate-100 border border-slate-200 p-4 rounded-lg flex flex-col">
                                 <h3 className="text-lg md:text-xl font-semibold text-green-600 mb-3">Aplicações Sugeridas</h3>
                                  <div className="space-y-3 flex-grow overflow-y-auto pr-1">
                                      {Object.values(applications).flat().length > 0 ? Object.entries(applications).map(([inst, apps]) => (
                                          apps.length > 0 && ( // Render only if institution has apps
                                              <div key={inst} className="mb-2">
                                                  <h4 className="font-bold text-slate-600 text-xs md:text-sm mb-1">{inst}</h4>
                                                  {apps.map((app, i) => (
                                                      <div key={i} className="flex justify-between items-center text-xs md:text-sm p-2 bg-white rounded border border-slate-200 mb-1">
                                                          <p className="font-semibold text-slate-700 truncate" title={app.name}>{app.name}</p>
                                                          <p className="font-bold text-green-500 whitespace-nowrap">{formatCurrency(app.value)}</p>
                                                      </div>
                                                  ))}
                                              </div>
                                          )
                                      )) : <p className="text-slate-500 text-sm italic">Nenhuma aplicação necessária.</p>}
                                  </div>
                                 <div className="border-t border-slate-300 mt-3 pt-3 flex justify-between font-bold text-sm md:text-base flex-shrink-0">
                                     <span>Total Aplicado:</span>
                                     <span className="text-green-600">{formatCurrency(totalApplied)}</span>
                                 </div>
                             </div>

                             {/* Timeline */}
                              {sortedTimelineDays.length > 0 && (
                                <div className="bg-slate-100 border border-slate-200 p-4 rounded-lg flex flex-col lg:col-span-2">
                                    <h3 className="text-lg md:text-xl font-semibold text-sky-600 mb-3 flex items-center">
                                       <Icon path={ICONS.CLOCK} className="h-5 w-5 mr-2"/> Disponibilidade de Caixa
                                    </h3>
                                    <div className="space-y-2 overflow-y-auto">
                                        {sortedTimelineDays.map(days => (
                                            <div key={days} className="text-xs md:text-sm">
                                                <span className="font-semibold text-slate-700">
                                                    {days === 0 ? 'D+0 (Hoje):' : `D+${days}:`}
                                                </span>
                                                <span className="font-bold text-sky-700 ml-2">{formatCurrency(fundsTimeline[days].totalAmount)}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                              )}
                         </div>
                      )}
                 </React.Fragment>
            )
        };

        // --- NEW/MODIFIED Projected Portfolio Slides ---

        // Helper to calculate projected analysis (used by both slides)
        const calculateProjectedAnalysis = (analysis, redemptions, applications) => {
            if (!analysis) return null;
            let projectedPortfolio = JSON.parse(JSON.stringify(analysis.portfolio)); // Deep copy

             // Apply redemptions
             const redemptionMap = {};
             Object.values(redemptions).forEach(({ asset, amount }) => {
                 // Use original value in ID for matching
                const assetId = `${asset.Instituição}-${asset["Número da Conta"] || 'noAcc'}-${asset.Nome}-${asset.Valor}`;
                redemptionMap[assetId] = (redemptionMap[assetId] || 0) + amount;
             });

            projectedPortfolio = projectedPortfolio.map(asset => {
                 const assetId = `${asset.Instituição}-${asset["Número da Conta"] || 'noAcc'}-${asset.Nome}-${asset.Valor}`;
                 if (redemptionMap[assetId]) {
                      // Subtract redemption, ensure value doesn't go below zero
                     asset.Valor = Math.max(0, asset.Valor - redemptionMap[assetId]);
                 }
                 return asset;
             }).filter(asset => asset.Valor > 0.001); // Remove assets with negligible value

             // Apply applications
             Object.entries(applications).forEach(([institution, apps]) => {
                 apps.forEach(app => {
                     const [inst, conta] = institution.split(' - ');
                     projectedPortfolio.push({
                         "Instituição": inst,
                         "Número da Conta": conta || '',
                         "Nome": app.name,
                         "Valor": app.value,
                         "Classe": app.Classe.split(' - ')[0], // Extract main class
                         "Subclasse": app.Classe.split(' - ')[1] || '', // Extract subclass
                         // Add placeholders for other fields
                         "Emissor": '', "Vencimento": '', "Taxa": '', "Liquidez": '', "Tipo de Ativo": 'Nova Aplicação',
                     });
                 });
             });

             const newTotalValue = projectedPortfolio.reduce((sum, asset) => sum + (asset.Valor || 0), 0);

             // Group by main class for chart/summary
             const allocationByMainClass = projectedPortfolio.reduce((acc, asset) => {
                 const key = asset.Classe;
                 if (!acc[key]) acc[key] = { name: key, value: 0 };
                 acc[key].value += (asset.Valor || 0);
                 return acc;
             }, {});

             // Group by institution for summary
              const allocationByInstitution = projectedPortfolio.reduce((acc, asset) => {
                  const key = asset.Instituição + (asset["Número da Conta"] ? ` - ${asset["Número da Conta"]}` : '');
                  if (!acc[key]) acc[key] = { name: key, value: 0 };
                  acc[key].value += (asset.Valor || 0);
                  return acc;
              }, {});


             return {
                 totalValue: newTotalValue,
                 chartData: Object.values(allocationByMainClass).filter(d => d.value > 0), // Data for pie chart
                 portfolio: projectedPortfolio, // Full projected portfolio
                 valuePerClass: Object.values(allocationByMainClass).filter(d => d.value > 0).sort((a,b)=>b.value-a.value), // Sorted list for table
                 valuePerInstitution: Object.values(allocationByInstitution).filter(d => d.value > 0).sort((a,b)=>b.value-a.value) // Sorted list for table
             };
        };


        // Projected Portfolio Slide 1: Summary (Chart, Value/Class, Value/Institution)
        const ProjectedPortfolioSlide = ({ analysis, redemptions, applications }) => {
            const projectedAnalysis = useMemo(() => calculateProjectedAnalysis(analysis, redemptions, applications), [analysis, redemptions, applications]);

            if (!projectedAnalysis || projectedAnalysis.portfolio.length === 0) {
                 return <p className="text-slate-500 text-center">Não foi possível calcular a carteira projetada ou ela está vazia.</p>;
            }

            return (
                 <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 h-full">
                     {/* Left Side: Chart and Total */}
                     <div className="flex flex-col space-y-4">
                          <h3 className="text-xl md:text-2xl font-bold text-slate-800 text-center">Nova Distribuição por Estratégia</h3>
                          <p className="text-slate-600 text-center text-sm md:text-base">
                              Valor Total Projetado: <span className="font-bold text-slate-800">{formatCurrency(projectedAnalysis.totalValue)}</span>
                          </p>
                         <div className="flex-grow min-h-[250px]">
                             <SvgPieChart data={projectedAnalysis.chartData} title="" /> {/* Title removed as it's above */}
                         </div>
                     </div>

                     {/* Right Side: Tables */}
                     <div className="space-y-4 overflow-y-auto flex flex-col">
                          {/* Value per Class Table */}
                         <div className="bg-slate-100 border border-slate-200 p-3 rounded-lg flex-grow flex flex-col">
                             <h4 className="text-base md:text-lg font-semibold text-slate-700 mb-2 flex-shrink-0">Valor por Classe</h4>
                             <div className="overflow-y-auto flex-grow">
                                 <table className="w-full text-left text-xs md:text-sm">
                                     <tbody>
                                         {projectedAnalysis.valuePerClass.map((item, i) => (
                                             <tr key={i} className="border-b border-slate-200 last:border-b-0">
                                                 <td className="py-1 pr-2">{item.name}</td>
                                                 <td className="py-1 px-2 text-right font-semibold">{formatCurrency(item.value)}</td>
                                                 <td className="py-1 pl-2 text-right text-slate-500">
                                                     {formatPercent(projectedAnalysis.totalValue > 0 ? item.value / projectedAnalysis.totalValue : 0)}
                                                 </td>
                                             </tr>
                                         ))}
                                     </tbody>
                                 </table>
                            </div>
                         </div>
                          {/* Value per Institution Table */}
                          <div className="bg-slate-100 border border-slate-200 p-3 rounded-lg flex-grow flex flex-col">
                             <h4 className="text-base md:text-lg font-semibold text-slate-700 mb-2 flex-shrink-0">Valor por Instituição</h4>
                              <div className="overflow-y-auto flex-grow">
                                 <table className="w-full text-left text-xs md:text-sm">
                                     <tbody>
                                         {projectedAnalysis.valuePerInstitution.map((item, i) => (
                                             <tr key={i} className="border-b border-slate-200 last:border-b-0">
                                                 <td className="py-1 pr-2 truncate" title={item.name}>{item.name}</td>
                                                 <td className="py-1 px-2 text-right font-semibold">{formatCurrency(item.value)}</td>
                                                 <td className="py-1 pl-2 text-right text-slate-500">
                                                     {formatPercent(projectedAnalysis.totalValue > 0 ? item.value / projectedAnalysis.totalValue : 0)}
                                                 </td>
                                             </tr>
                                         ))}
                                     </tbody>
                                 </table>
                             </div>
                         </div>
                     </div>
                 </div>
            );
        };


         // Projected Portfolio Slide 2: Assets Grouped by Class
         const ProjectedAssetsByClassSlide = ({ projectedAnalysis }) => {
             // Group assets by main class
             const assetsByClass = useMemo(() => {
                 if (!projectedAnalysis || !projectedAnalysis.portfolio) return {};
                 return projectedAnalysis.portfolio.reduce((acc, asset) => {
                     const key = asset.Classe;
                     if (!acc[key]) acc[key] = [];
                     acc[key].push(asset);
                     // Sort assets within each class by value (desc)
                     acc[key].sort((a,b) => b.Valor - a.Valor);
                     return acc;
                 }, {});
             }, [projectedAnalysis]);

             const sortedClasses = Object.keys(assetsByClass).sort((a, b) => {
                  // Calculate total value for each class to sort classes by value
                 const totalA = assetsByClass[a].reduce((sum, asset) => sum + asset.Valor, 0);
                 const totalB = assetsByClass[b].reduce((sum, asset) => sum + asset.Valor, 0);
                 return totalB - totalA;
             });

             if (!projectedAnalysis || sortedClasses.length === 0) {
                 return <p className="text-slate-500 text-center">Nenhum ativo na carteira projetada.</p>;
             }

             return (
                 <div className="h-full overflow-y-auto space-y-4">
                     {sortedClasses.map(className => (
                         <div key={className} className="bg-slate-100 border border-slate-200 p-3 rounded-lg">
                             <h4 className="text-base md:text-lg font-semibold text-slate-700 mb-2">{className}</h4>
                             <table className="w-full text-left text-xs md:text-sm">
                                 <thead>
                                     <tr className="border-b border-slate-300">
                                         <th className="py-1 pr-2 font-medium text-slate-500">Ativo</th>
                                         <th className="py-1 px-2 font-medium text-slate-500">Instituição</th>
                                         <th className="py-1 px-2 font-medium text-slate-500 text-right">Valor</th>
                                         <th className="py-1 pl-2 font-medium text-slate-500 text-right">% Total</th>
                                     </tr>
                                 </thead>
                                 <tbody>
                                     {assetsByClass[className].map((asset, i) => (
                                         <tr key={i} className="border-b border-slate-200 last:border-b-0">
                                             <td className="py-1 pr-2 text-slate-800 truncate" title={asset.Nome}>{asset.Nome}</td>
                                              <td className="py-1 px-2 text-slate-600 truncate" title={asset.Instituição}>{asset.Instituição}</td>
                                             <td className="py-1 px-2 text-right font-medium text-slate-800">{formatCurrency(asset.Valor)}</td>
                                             <td className="py-1 pl-2 text-right text-slate-500">
                                                 {formatPercent(projectedAnalysis.totalValue > 0 ? asset.Valor / projectedAnalysis.totalValue : 0)}
                                             </td>
                                         </tr>
                                     ))}
                                 </tbody>
                             </table>
                         </div>
                     ))}
                 </div>
             );
         };

        // --- NEW: Liquidity Slide ---
        const LiquiditySlide = ({ analysis }) => {
             if (!analysis || !analysis.liquidityBuckets) {
                 return <p className="text-slate-500">Dados de liquidez não disponíveis.</p>;
             }
             const bucketData = Object.entries(analysis.liquidityBuckets).map(([key, data]) => ({
                 name: data.label,
                 value: data.value,
                 key: key
             }));
             const order = ['D-0', 'D-5', 'D-30', 'D-180', 'D-365', 'D+365'];
             const sortedBucketData = bucketData.sort((a, b) => order.indexOf(a.key) - order.indexOf(b.key));

             return (
                 <div className="h-full flex flex-col">
                     <div className="flex-grow">
                         <CssBarChart data={sortedBucketData} title="" /> {/* Title provided by slide header */}
                     </div>
                      {/* Optional: Add table view below chart if space permits */}
                     <div className="bg-slate-100 border border-slate-200 p-3 rounded-lg mt-4 flex-shrink-0">
                         <table className="w-full text-left text-xs md:text-sm">
                              <thead className="border-b border-slate-300">
                                 <tr>
                                     <th className="py-1 pr-2 font-medium text-slate-500">Prazo</th>
                                     <th className="py-1 px-2 font-medium text-slate-500 text-right">Valor</th>
                                     <th className="py-1 pl-2 font-medium text-slate-500 text-right">% Total</th>
                                 </tr>
                             </thead>
                             <tbody>
                                 {sortedBucketData.map(bucket => (
                                     <tr key={bucket.key} className="border-b border-slate-200 last:border-b-0">
                                         <td className="py-1 pr-2 text-slate-700">{bucket.name}</td>
                                         <td className="py-1 px-2 text-right font-semibold text-slate-800">{formatCurrency(bucket.value)}</td>
                                         <td className="py-1 pl-2 text-right text-slate-500">
                                             {formatPercent(analysis.totalValue > 0 ? bucket.value / analysis.totalValue : 0)}
                                         </td>
                                     </tr>
                                 ))}
                             </tbody>
                              <tfoot className="border-t-2 border-slate-300 font-bold">
                                 <tr>
                                     <td className="py-1 pr-2 text-slate-800">TOTAL</td>
                                     <td className="py-1 px-2 text-right text-slate-800">{formatCurrency(analysis.totalValue)}</td>
                                     <td className="py-1 pl-2 text-right text-slate-800">100,00%</td>
                                 </tr>
                             </tfoot>
                         </table>
                     </div>
                 </div>
             );
        };


        // --- Other Slide Components (Issuer, AssetType, Quotation) ---
        // These remain largely the same but ensure they use appropriate styling for print/screen if needed
        const IssuerConcentrationSlide = ({ analysis }) => {
             const issuerData = useMemo(() => {
                 if (!analysis || !analysis.issuerConcentration) return null;
                 const sorted = Object.entries(analysis.issuerConcentration)
                     .map(([name, value]) => ({ name, value }))
                     .sort((a, b) => b.value - a.value);
                 return sorted;
             }, [analysis]);

             return (
                  <React.Fragment>
                      {!issuerData ? <p className="text-slate-500">Dados de emissor não disponíveis.</p> : (
                           // Ensure chart component is used correctly
                           <CssBarChart data={issuerData} title="" />
                      )}
                  </React.Fragment>
             );
        };

        const AssetTypeSlide = ({ analysis }) => {
              const assetTypeData = useMemo(() => {
                  if (!analysis || !analysis.allocationByAssetType) return null;
                  return Object.entries(analysis.allocationByAssetType)
                      .map(([name, data]) => ({ name, value: data.value }))
                      .sort((a, b) => b.value - a.value);
              }, [analysis]);

              return (
                   <React.Fragment>
                       {!assetTypeData ? <p className="text-slate-500">Dados de tipo de ativo não disponíveis.</p> : (
                            <CssBarChart data={assetTypeData} title="" />
                       )}
                   </React.Fragment>
              );
        };

         const QuotationSlide = ({ redemptions, quotations }) => {
             const totals = useMemo(() => {
                 let totalTela = 0, totalResgate = 0;
                 Object.values(redemptions).forEach(({asset, amount}) => {
                     const assetId = `${asset.Instituição}-${asset["Número da Conta"] || 'noAcc'}-${asset.Nome}-${asset.Valor}`;
                     totalTela += amount;
                     totalResgate += (quotations[assetId] || 0); // Use 0 if quote not entered
                 });
                 const totalDesagio = totalTela - totalResgate;
                 const totalDesagioPercent = totalTela > 0 ? totalDesagio / totalTela : 0;
                 return { totalTela, totalResgate, totalDesagio, totalDesagioPercent };
             }, [redemptions, quotations]);

              // Check if there are any redemptions to display
             if (Object.keys(redemptions).length === 0) {
                 return <p className="text-slate-500 text-center">Nenhum ativo selecionado para cotação de resgate.</p>;
             }

             return (
                  <div className="h-full overflow-y-auto">
                      <div className="bg-slate-100 border border-slate-200 rounded-lg shadow-sm overflow-hidden">
                          <table className="w-full text-left">
                             <thead className="border-b border-slate-300 bg-slate-50">
                                  <tr>
                                      <th className="p-2 md:p-3 text-xs md:text-sm font-semibold text-slate-600">Ativo</th>
                                      <th className="p-2 md:p-3 text-xs md:text-sm font-semibold text-slate-600 text-right">Valor de Tela</th>
                                      <th className="p-2 md:p-3 text-xs md:text-sm font-semibold text-slate-600 text-right">Valor de Resgate</th>
                                      <th className="p-2 md:p-3 text-xs md:text-sm font-semibold text-slate-600 text-right">Deságio (R$)</th>
                                      <th className="p-2 md:p-3 text-xs md:text-sm font-semibold text-slate-600 text-right">Deságio (%)</th>
                                  </tr>
                              </thead>
                              <tbody>
                                  {Object.values(redemptions).map(({ asset, amount }, index) => {
                                      const assetId = `${asset.Instituição}-${asset["Número da Conta"] || 'noAcc'}-${asset.Nome}-${asset.Valor}`;
                                      const valorTela = amount;
                                      const valorResgate = quotations[assetId] || 0; // Default to 0 if not quoted
                                      const desagioValor = valorTela - valorResgate;
                                      const desagioPercent = valorTela > 0 ? (desagioValor / valorTela) : 0;
                                      return (
                                          <tr key={assetId} className="border-b border-slate-200 last:border-b-0 text-xs md:text-sm">
                                              <td className="p-2 md:p-3 font-medium text-slate-800">{asset.Nome}<p className="text-[10px] md:text-xs text-slate-500">{asset.Instituição}</p></td>
                                              <td className="p-2 md:p-3 text-slate-700 text-right whitespace-nowrap">{formatCurrency(valorTela)}</td>
                                              <td className="p-2 md:p-3 text-slate-700 text-right whitespace-nowrap">{formatCurrency(valorResgate)}</td>
                                              <td className="p-2 md:p-3 text-red-600 text-right whitespace-nowrap">{formatCurrency(desagioValor)}</td>
                                              <td className="p-2 md:p-3 text-red-600 text-right whitespace-nowrap">{formatPercent(desagioPercent)}</td>
                                          </tr>
                                      );
                                  })}
                              </tbody>
                              <tfoot className="border-t-2 border-slate-400 bg-slate-200">
                                  <tr className="font-bold text-sm md:text-base">
                                      <td className="p-3 text-slate-800">TOTAIS</td>
                                      <td className="p-3 text-slate-800 text-right">{formatCurrency(totals.totalTela)}</td>
                                      <td className="p-3 text-slate-800 text-right">{formatCurrency(totals.totalResgate)}</td>
                                      <td className="p-3 text-red-700 text-right">{formatCurrency(totals.totalDesagio)}</td>
                                      <td className="p-3 text-red-700 text-right">{formatPercent(totals.totalDesagioPercent)}</td>
                                  </tr>
                              </tfoot>
                          </table>
                      </div>
                  </div>
             );
         };



        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>

